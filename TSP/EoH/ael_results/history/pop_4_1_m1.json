{
     "parent1": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, with the noise factor being a random value between -1 and 1, to escape from the local optimum and move towards a global optimum. \n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        updated_edge_distance[start_node][end_node] += np.random.uniform(-1, 1)\n    \n    return updated_edge_distance",
          "objective": 0.2165,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Randomly select a pair of nodes from the local optimal route, and then swap the edge distances between these nodes with a random noise factor between -1 and 1, to escape from the local optimum and move towards a global optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    # Randomly select a pair of nodes from the local optimal route\n    node_indices = np.random.choice(len(local_opt_tour), 2, replace=False)\n    node1 = local_opt_tour[node_indices[0]]\n    node2 = local_opt_tour[node_indices[1]]\n    \n    # Swap the edge distances between the selected nodes with a random noise factor\n    edge_index_1 = edge_n_used[node1][node2]\n    edge_index_2 = edge_n_used[node2][node1]\n    updated_edge_distance[node1][node2] += np.random.uniform(-1, 1)\n    updated_edge_distance[node2][node1] += np.random.uniform(-1, 1)\n    \n    return updated_edge_distance",
          "objective": 1.76798,
          "other_inf": null
     }
}