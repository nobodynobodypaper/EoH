{
     "parent1": {
          "algorithm": "\nNew algorithm: Use local_opt_tour to identify edges with the highest number of uses and update the distance matrix accordingly, then sort the nodes based on the impact of perturbing them on the tour's distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = np.copy(distance_matrix)\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n        edge_n_used[node1 - 1][node2 - 1] += 1\n        new_distance_matrix[node1 - 1][node2 - 1] += edge_n_used[node1 - 1][node2 - 1]\n        new_distance_matrix[node2 - 1][node1 - 1] += edge_n_used[node2 - 1][node1 - 1]\n\n    # Sort nodes based on impact of perturbing them\n    perturb_nodes = np.argsort(np.sum(edge_n_used, axis=1))[::-1]\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 2.98129,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Use local_opt_tour to identify edges with the highest number of uses and update the distance matrix accordingly, then sort the nodes based on a customized score function that incorporates the impact of perturbing them and their proximity to the current tour, rather than just the total number of uses.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = np.copy(distance_matrix)\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n        edge_n_used[node1 - 1][node2 - 1] += 1\n        new_distance_matrix[node1 - 1][node2 - 1] += edge_n_used[node1 - 1][node2 - 1]\n        new_distance_matrix[node2 - 1][node1 - 1] += edge_n_used[node2 - 1][node1 - 1]\n\n    # Sort nodes based on customized score function\n    perturb_scores = np.zeros(len(edge_n_used))\n    for i in range(len(perturb_scores)):\n        perturb_scores[i] = calculate_perturb_score(i, edge_n_used, distance_matrix, local_opt_tour)\n    perturb_nodes = np.argsort(perturb_scores)[::-1]\n\n    return new_distance_matrix, perturb_nodes\n\ndef calculate_perturb_score(node, edge_n_used, distance_matrix, local_opt_tour):\n    score = 0\n    for i in range(len(local_opt_tour) - 1):\n        current_node = local_opt_tour[i] - 1\n        next_node = local_opt_tour[i + 1] - 1\n        score += edge_n_used[current_node][next_node] * distance_matrix[current_node][node]\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}