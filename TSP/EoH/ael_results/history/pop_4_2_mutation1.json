{
     "parent1": {
          "algorithm": "\n\nAlgorithm description: \nThe new algorithm idea is to create a new distance matrix based on the local optimal tour, global optimal tour, and number of times each edge is used. Then, it will identify the most critical nodes to perturb based on the edges with the highest usage in the updated distance matrix. In contrast to the previous algorithms, this approach aims to prioritize perturbation based on the impact of edge usage on the distance matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Create new distance matrix based on local optimal tour, global optimal tour, and edge usage\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n\n    # Identify perturb nodes based on edges with highest usage in updated distance matrix\n    perturb_nodes = np.argsort(-edge_n_used.sum(axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.326,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: \nThe new algorithm idea is to first construct a graph based on the distances and optimal tours, then find the shortest path from each node to the global optimal tour using Dijkstra's algorithm. Finally, it will calculate the potential impact of perturbing each node based on the reduction in total distance and sort them accordingly.\n\nCode:\nimport numpy as np\nimport networkx as nx\n\ndef dijkstra_shortest_path(graph, start, end):\n    path = nx.shortest_path(graph, source=start, target=end, weight='weight')\n    return sum([graph[path[i]][path[i+1]]['weight'] for i in range(len(path)-1)])\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    graph = nx.from_numpy_array(distance_matrix, create_using=nx.DiGraph)\n    perturb_impact = np.zeros(distance_matrix.shape[0])\n\n    for node in range(distance_matrix.shape[0]):\n        if node not in global_opt_tour:\n            shortest_to_global = min([dijkstra_shortest_path(graph, node, global_opt_tour[i]) for i in range(len(global_opt_tour))])\n            perturb_impact[node] = np.sum(edge_n_used[node] * (distance_matrix[node] - shortest_to_global))\n\n    perturb_nodes = np.argsort(perturb_impact)[::-1]\n    return distance_matrix * (1 + edge_n_used), perturb_nodes\n",
          "code": "import numpy as np\nimport networkx as nx\n\ndef dijkstra_shortest_path(graph, start, end):\n    path = nx.shortest_path(graph, source=start, target=end, weight='weight')\n    return sum([graph[path[i]][path[i+1]]['weight'] for i in range(len(path)-1)])\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    graph = nx.from_numpy_array(distance_matrix, create_using=nx.DiGraph)\n    perturb_impact = np.zeros(distance_matrix.shape[0])\n\n    for node in range(distance_matrix.shape[0]):\n        if node not in global_opt_tour:\n            shortest_to_global = min([dijkstra_shortest_path(graph, node, global_opt_tour[i]) for i in range(len(global_opt_tour))])\n            perturb_impact[node] = np.sum(edge_n_used[node] * (distance_matrix[node] - shortest_to_global))\n\n    perturb_nodes = np.argsort(perturb_impact)[::-1]\n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}