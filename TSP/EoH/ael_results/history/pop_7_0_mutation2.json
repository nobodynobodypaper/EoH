{
     "parent2": {
          "algorithm": "The new algorithm aims to update the distance matrix by incorporating a weighted combination of the impact on both the local and global optimal tours. It first calculates the average distance traveled by each node in the local optimal tour and uses this information to update the distance matrix. It then calculates the impact of perturbing each node by considering both the local and global optimal tours, and finally sorts the nodes based on their impact to determine the top ones to perturb.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_dist_traveled = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour)-1):\n        avg_dist_traveled[local_opt_tour[i]] += np.sum(distance_matrix[local_opt_tour[i], local_opt_tour[i+1:]])/(len(local_opt_tour)-1-i)\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n\n    local_tour_impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        local_tour_impact[local_opt_tour[i]] += np.sum(new_distance_matrix[local_opt_tour[i], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i]]) - new_distance_matrix[local_opt_tour[i], local_opt_tour[i]]\n        local_tour_impact[local_opt_tour[i+1]] += np.sum(new_distance_matrix[local_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i+1]]) - new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i+1]]\n    \n    global_tour_impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(global_opt_tour) - 1):\n        global_tour_impact[global_opt_tour[i]] += np.sum(new_distance_matrix[global_opt_tour[i], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i]]) - new_distance_matrix[global_opt_tour[i], global_opt_tour[i]]\n        global_tour_impact[global_opt_tour[i+1]] += np.sum(new_distance_matrix[global_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i+1]]) - new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i+1]]\n    \n    impact = local_tour_impact + global_tour_impact + avg_dist_traveled\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.023,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm aims to utilize a combination of the impact of perturbing each node based on the local and global optimal tours, while also incorporating the average distance traveled by each node in the local optimal tour. The main steps include calculating the average distance traveled by each node in the local optimal tour, updating the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and sorting the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_dist_traveled = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour)-1):\n        avg_dist_traveled[local_opt_tour[i]] += np.sum(distance_matrix[local_opt_tour[i], local_opt_tour[i+1:]])/(len(local_opt_tour)-1-i)\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n\n    local_tour_impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        local_tour_impact[local_opt_tour[i]] += np.sum(new_distance_matrix[local_opt_tour[i], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i]]) - new_distance_matrix[local_opt_tour[i], local_opt_tour[i]]\n        local_tour_impact[local_opt_tour[i+1]] += np.sum(new_distance_matrix[local_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i+1]]) - new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i+1]\n    \n    global_tour_impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(global_opt_tour) - 1):\n        global_tour_impact[global_opt_tour[i]] += np.sum(new_distance_matrix[global_opt_tour[i], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i]]) - new_distance_matrix[global_opt_tour[i], global_opt_tour[i]]\n        global_tour_impact[global_opt_tour[i+1]] += np.sum(new_distance_matrix[global_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i+1]]) - new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i+1]\n    \n    impact = local_tour_impact + global_tour_impact + avg_dist_traveled\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}