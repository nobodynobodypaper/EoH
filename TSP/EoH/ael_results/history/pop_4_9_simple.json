{
     "parent1": {
          "algorithm": "Create a new algorithm that updates the distance matrix by applying a custom nonlinear transformation to the edge usage and incorporates the difference between the local and global optimum tours, then sorting the nodes based on a novel scoring function.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Apply a custom nonlinear transformation to the edge usage\n    transformed_edge_usage = np.power(edge_n_used, 2)\n    \n    # Incorporate the difference between local and global optimum tours\n    tour_difference = np.abs(global_opt_tour - local_opt_tour)\n    new_distance_matrix = distance_matrix + transformed_edge_usage - tour_difference\n    \n    # Sort the nodes based on a novel scoring function\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1) * np.max(transformed_edge_usage, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.11364,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix by applying a custom nonlinear transformation to the edge usage and incorporates the difference between the local and global optimum tours, then sorting the nodes based on a novel scoring function.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    transformed_edge_usage = np.power(edge_n_used, 2)\n    tour_difference = np.abs(global_opt_tour - local_opt_tour)\n    new_distance_matrix = distance_matrix + transformed_edge_usage - tour_difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.13619,
          "other_inf": null
     }
}