{
     "parent1": {
          "algorithm": "Create an algorithm that updates the distance matrix by incorporating a combination of the edge usage, the difference between local and global optimum tours, and a randomized factor, then sorts the nodes based on the maximum edge usage and the minimum distance from the global optimum tour to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    update_factor = (0.4 * edge_n_used) + (0.4 * (local_opt_tour - global_opt_tour)) + (0.2 * np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1]))\n    new_distance_matrix = update_factor + distance_matrix\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08105,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create an algorithm that updates the distance matrix by incorporating a combination of the edge usage, the difference between local and global optimum tours, and a randomized factor, then sorts the nodes based on the maximum edge usage and the minimum distance from the global optimum tour to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    update_factor = (0.2 * edge_n_used) + (0.2 * (local_opt_tour - global_opt_tour)) + (0.6 * np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1]))\n    new_distance_matrix = update_factor + distance_matrix\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.14429,
          "other_inf": null
     }
}