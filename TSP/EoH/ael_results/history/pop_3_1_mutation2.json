{
     "parent2": {
          "algorithm": "\n\nAlgorithm description: \nThe new algorithm idea is to create a new distance matrix based on the local optimal tour, global optimal tour, and number of times each edge is used. Then, it will identify the most critical nodes to perturb based on the edges with the highest usage in the updated distance matrix. In contrast to the previous algorithms, this approach aims to prioritize perturbation based on the impact of edge usage on the distance matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Create new distance matrix based on local optimal tour, global optimal tour, and edge usage\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n\n    # Identify perturb nodes based on edges with highest usage in updated distance matrix\n    perturb_nodes = np.argsort(-edge_n_used.sum(axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.326,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: \nIdea: The new algorithm will first calculate the impact of edge usage on the distance matrix and identify the most critical nodes to perturb based on this analysis, prioritizing nodes with the highest impact on the overall distance.\n\nCode:\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Calculate the impact of edge usage on the distance matrix\n    edge_impact = distance_matrix * edge_n_used\n    \n    # Identify perturb nodes based on the impact of edge usage on the distance matrix\n    perturb_nodes = np.argsort(-edge_impact.sum(axis=1))\n    \n    # Update distance matrix based on the local and global optimal tour\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.51,
          "first_obj": null
     }
}