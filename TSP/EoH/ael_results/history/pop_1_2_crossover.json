{
     "parent1": {
          "algorithm": "\nThe algorithm will first update the distance matrix based on the local optimal tour, global optimal tour, and the number of times each edge is used. Then, it will sort the nodes based on some heuristic to provide the top nodes to perturb in order to avoid being trapped in the local optimum tour.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n    \n    # Sort nodes based on some heuristic\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.56,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "\nThe algorithm will first update the distance matrix by adding a penalty to the edges used in the local_opt_tour and global_opt_tour. Then, it will sort the nodes based on the penalty of their edges and return the top nodes to perturb to avoid being trapped in a local optimum tour.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    penalty = 1000  # Penalty for the edges used in the local_opt_tour and global_opt_tour\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        from_node = local_opt_tour[i]\n        to_node = local_opt_tour[i+1]\n        new_distance_matrix[from_node][to_node] += penalty\n        new_distance_matrix[to_node][from_node] += penalty\n    \n    for i in range(len(global_opt_tour) - 1):\n        from_node = global_opt_tour[i]\n        to_node = global_opt_tour[i+1]\n        new_distance_matrix[from_node][to_node] += penalty\n        new_distance_matrix[to_node][from_node] += penalty\n    \n    edge_penalty_sum = np.sum(new_distance_matrix, axis=1)\n    perturb_nodes = np.argsort(-edge_penalty_sum)  # Sort nodes based on edge penalty sum in descending order\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.713,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: \nThe algorithm will update the distance matrix by considering the frequency of edges used in the local optimum tour and global optimum tour, and then sort the nodes based on their connectivity and the frequency of edges used, providing the top nodes to perturb to avoid being trapped in the local optimum tour.\n\nCode:\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix based on edge frequency and connectivity\n    new_distance_matrix = distance_matrix + (edge_n_used / np.sum(edge_n_used))\n    \n    # Sort nodes based on connectivity and edge frequency\n    node_connectivity = np.sum(new_distance_matrix, axis=1)\n    perturb_nodes = np.argsort(node_connectivity)\n    \n    return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix based on edge frequency and connectivity\n    new_distance_matrix = distance_matrix + (edge_n_used / np.sum(edge_n_used))\n    \n    # Sort nodes based on connectivity and edge frequency\n    node_connectivity = np.sum(new_distance_matrix, axis=1)\n    perturb_nodes = np.argsort(node_connectivity)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.904,
          "first_obj": null
     }
}