{
     "parent1": {
          "algorithm": "\nThe common backbone idea in the provided algorithms is to update the distance matrix based on unique scoring functions incorporating local optimum, global optimum, and edge usage, and then sort the nodes using different scoring functions for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Create a new algorithm that updates the distance matrix by taking the element-wise average between the distance matrix and a inverse matrix\n    new_distance_matrix = (distance_matrix + 1) / (np.random.rand(*distance_matrix.shape) + 1)\n    \n    # Sort the nodes using a different scoring function for perturbation based on the minimum distance matrix value\n    perturb_nodes = np.argsort(np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.09383,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix based on the local optimum tour, global optimum tour, and edge usage by implementing a unique scoring function, and then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different scoring function incorporating local optimum, global optimum, and edge usage\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) + (local_opt_tour - global_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)  # random perturbation\n\n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08595,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a combination of the edge usage, local and global optimum tours, and penalizing edges based on their current usage, and then sorts the nodes based on a scoring function that considers the product of edge usage and the difference between the local and global optimum tours to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a combination of edge usage and the difference between local and global optimum tours\n    new_distance_matrix = distance_matrix + (edge_n_used * 1.5) - 0.9 * (global_opt_tour - local_opt_tour)\n    \n    # Sort the nodes using the product of edge usage and the total distance difference for perturbation\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * edge_n_used, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.12725,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nNew algorithm description: Create a new algorithm that updates the distance matrix by incorporating a random perturbation, scaling the edge usage, penalizing edges used in the local optimal tour, and sorting the nodes based on the product of edge usage and the total distance difference to find the top ones to perturb using a different penalty factor.\n\nCode:\n\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour with a different penalty factor\n    penalty = 1.2\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage, axis=1))\n\n    return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour with a different penalty factor\n    penalty = 1.2\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10751,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the element-wise minimum between the distance matrix and a randomized matrix, incorporates the difference between the local and global optimum tour by subtracting it from the distance matrix, and sorts the nodes based on the sum of edge usage and the distance matrix to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.minimum(distance_matrix, np.random.rand(*distance_matrix.shape))\n    \n    new_distance_matrix -= local_opt_tour - global_opt_tour\n    \n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10009,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix by incorporating a combination of the edge usage, local and global optimum tours, and adding a random perturbation, and then sort the nodes using a unique scoring function based on the minimum distance matrix value to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a combination of edge usage, local and global optimum tours, and a random perturbation\n    new_distance_matrix = distance_matrix + (edge_n_used * 1.5) - 0.9 * (global_opt_tour - local_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Sort the nodes using the minimum distance matrix value for perturbation\n    perturb_nodes = np.argsort(np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.171,
          "other_inf": null
     }
}