{
     "parent2": {
          "algorithm": "The algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours. However, instead of directly sorting the nodes based on their impact, we will first create a priority queue where the priority is based on the impact value. Then, we will dequeue the top nodes from the priority queue to get the nodes to perturb.",
          "code": "import numpy as np\nimport heapq\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = []\n    for node, imp in enumerate(impact):\n        heapq.heappush(perturb_nodes, (imp, node))\n    \n    perturb_nodes = [node for _, node in perturb_nodes]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.937,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\n  The new algorithm aims to update the distance matrix by considering the impact of perturbing each node based on the local optimal tour, global optimal tour, and edge usage. Then, it will sort the nodes based on their impact while avoiding redundant calculations and unnecessary data structures.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    \n    # Updating the distance matrix and calculating the impact\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n        edge_usage = edge_n_used[node1, node2]\n\n        new_distance_matrix[node1, node2] += edge_usage\n        new_distance_matrix[node2, node1] += edge_usage\n\n        impact[node1] += np.sum(new_distance_matrix[node1, :]) + np.sum(new_distance_matrix[:, node1]) - new_distance_matrix[node1, node1]\n        impact[node2] += np.sum(new_distance_matrix[node2, :]) + np.sum(new_distance_matrix[:, node2]) - new_distance_matrix[node2, node2]\n    \n    for i in range(len(global_opt_tour) - 1):\n        node1 = global_opt_tour[i]\n        node2 = global_opt_tour[i + 1]\n        edge_usage = edge_n_used[node1, node2]\n\n        new_distance_matrix[node1, node2] += edge_usage\n        new_distance_matrix[node2, node1] += edge_usage\n        \n        impact[node1] += np.sum(new_distance_matrix[node1, :]) + np.sum(new_distance_matrix[:, node1]) - new_distance_matrix[node1, node1]\n        impact[node2] += np.sum(new_distance_matrix[node2, :]) + np.sum(new_distance_matrix[:, node2]) - new_distance_matrix[node2, node2]\n\n    # Sorting the nodes based on their impact in descending order\n    perturb_nodes = np.argsort(-impact)\n        \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.038,
          "first_obj": null
     }
}