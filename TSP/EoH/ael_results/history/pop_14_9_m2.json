{
     "parent1": {
          "algorithm": "Create an algorithm that updates the distance matrix by considering the percentage change in edge usage, incorporating the randomness factor, and incrementing the distance based on the difference between the local and global optimum tours, then sorts the nodes based on the minimum distance from the global optimum tour and maximum edge usage to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    percentage_edge_usage_change = (edge_n_used - np.mean(edge_n_used)) / np.mean(edge_n_used)\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = distance_matrix + (0.3 * percentage_edge_usage_change) + (0.4 * randomness) + (0.3 * (global_opt_tour - local_opt_tour))\n    perturb_nodes = np.argsort(0.4 * np.min(new_distance_matrix, axis=1) + 0.6 * np.max(edge_n_used, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10431,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create an algorithm that updates the distance matrix by considering the percentage change in edge usage, incorporating the randomness factor, and incrementing the distance based on the difference between the local and global optimum tours, then sorts the nodes based on the maximum distance from the global optimum tour and minimum edge usage to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    percentage_edge_usage_change = (edge_n_used - np.mean(edge_n_used)) / np.mean(edge_n_used)\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = distance_matrix + (0.3 * percentage_edge_usage_change) + (0.4 * randomness) + (0.3 * (global_opt_tour - local_opt_tour))\n    perturb_nodes = np.argsort(0.6 * np.max(new_distance_matrix, axis=1) + 0.4 * np.min(edge_n_used, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10607,
          "other_inf": null
     }
}