{
     "parent1": {
          "algorithm": "New algorithm: Update the edge distances in the edge distance matrix based on a combination of the frequency of each edge used in the local optimal tour and a custom function that incorporates edge count and distance, with the goal of guiding the search towards a globally optimal solution.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n\n    # Custom combination of edge count and distance\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_n_used[i][j] > 0:\n                custom_function = edge_n_used[i][j] * (1 / max(edge_n_used[i][j], 1)) + (edge_distance[i][j] / np.max(edge_distance))\n                updated_edge_distance[i][j] += custom_function\n\n    return updated_edge_distance",
          "objective": 3.49348,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "New algorithm: Update the edge distances in the edge distance matrix based on a combination of the frequency of each edge used in the local optimal tour and a custom function that incorporates edge count and distance, with the goal of guiding the search towards a globally optimal solution.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n\n    # Custom combination of edge count and distance\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            custom_function = edge_n_used[i][j] * 0.5 + (edge_distance[i][j] / np.max(edge_distance))\n            updated_edge_distance[i][j] += custom_function\n\n    return updated_edge_distance",
          "objective": 10000000000.0,
          "other_inf": null
     }
}