{
     "parent1": {
          "algorithm": "The common backbone idea in the provided algorithms is to update the distance matrix based on edge usage and node distances, and then sort the nodes to perturb to avoid being trapped in the local optimum tour.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Create a new algorithm that identifies the edges with the highest impact on the distance matrix, updates the matrix based on the edge usage, and sorts the nodes based on the impact for perturbation.\n    impact_edges = np.argmax(edge_n_used, axis=1)\n    new_distance_matrix = distance_matrix + (edge_n_used * 2)\n    perturb_nodes = np.argsort(impact_edges)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.24414,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "The common backbone idea in the provided algorithms is to update the distance matrix based on edge usage and node distances, and then sort the nodes to perturb to avoid being trapped in the local optimum tour.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, edge_n_used):\n    impact_edges = np.argmax(edge_n_used, axis=1)\n    new_distance_matrix = distance_matrix + (edge_n_used * 2)\n    perturb_nodes = np.argsort(impact_edges)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}