{
     "parent1": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the minimum frequency of each edge used in the local optimal tour and a custom transformation of the edge count and distance, incorporating a noise factor proportional to the reciprocal of the edge count and a scaled factor based on the distance to guide the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                noise_factor = (1 / max(edge_count[i][j], 1)) * (edge_distance[i][j] / np.max(edge_distance))\n                scaled_factor = 0.7 * np.random.uniform(0.5, 1.5) * (1 / edge_count[i][j]) + 0.3 * (edge_distance[i][j] / np.mean(edge_distance))\n                updated_edge_distance[i][j] += scaled_factor + noise_factor\n\n    return updated_edge_distance",
          "objective": 0.0467,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on a combination of the edge count, distance, and a custom transformation of the edge count incorporating a noise factor and a scaled factor to guide the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n  \n    # Your code implementation here\n  \n    return updated_edge_distance",
          "objective": 3.49348,
          "other_inf": null
     }
}