{
     "parent1": {
          "algorithm": "\nThe new algorithm will calculate the total distance reduction if each node is perturbed in the local optimal tour and also consider the distance increase if each node is perturbed in the global optimal tour. Then, it will update the distance matrix by penalizing the edges based on the frequency of use and the potential impact of perturbing each node, and finally sort the nodes based on the penalty and perturb impact to avoid being trapped in the local optimum tour.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    penalty = np.zeros(distance_matrix.shape)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        penalty[start][end] += 1\n        penalty[end][start] += 1\n    penalty = np.divide(penalty, edge_n_used, out=np.zeros_like(penalty), where=edge_n_used != 0)\n    perturb_impact_local = np.sum(edge_n_used * (distance_matrix - (distance_matrix + penalty * edge_n_used)), axis=1)\n    perturb_impact_global = np.sum(edge_n_used * ((distance_matrix + penalty * edge_n_used) - distance_matrix), axis=1)\n    perturb_nodes = np.argsort(-penalty.sum(axis=1) + perturb_impact_local - perturb_impact_global)[::-1]\n    new_distance_matrix = distance_matrix + penalty * edge_n_used\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.36,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm will first calculate the average distance between each pair of nodes in the local optimal tour and the global optimal tour, and then update the distance matrix by considering the difference between the average distances. Next, it will sort the nodes based on the average distance difference to identify the nodes with the highest potential impact, and finally return the updated distance matrix and the sorted nodes.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    local_avg_distance = np.zeros(distance_matrix.shape)\n    global_avg_distance = np.zeros(distance_matrix.shape)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        local_avg_distance[start][end] += distance_matrix[start][end]\n        local_avg_distance[end][start] += distance_matrix[end][start]\n    local_avg_distance = np.divide(local_avg_distance, edge_n_used, out=np.zeros_like(local_avg_distance), where=edge_n_used != 0)\n    \n    for i in range(len(global_opt_tour) - 1):\n        start = global_opt_tour[i]\n        end = global_opt_tour[i + 1]\n        global_avg_distance[start][end] += distance_matrix[start][end]\n        global_avg_distance[end][start] += distance_matrix[end][start]\n    global_avg_distance = np.divide(global_avg_distance, edge_n_used, out=np.zeros_like(global_avg_distance), where=edge_n_used != 0)\n\n    avg_distance_difference = local_avg_distance - global_avg_distance\n    perturb_nodes = np.argsort(-np.sum(avg_distance_difference, axis=1))[::-1]\n\n    new_distance_matrix = distance_matrix + avg_distance_difference\n    return new_distance_matrix, perturb_nodes",
          "objective": 4.292,
          "first_obj": null
     }
}