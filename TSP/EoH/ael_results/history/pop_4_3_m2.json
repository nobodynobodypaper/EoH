{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a random perturbation, scaling the edge usage, penalizing edges used in the local optimal tour, and sorting the nodes based on the product of edge usage and the total distance difference to find the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour\n    penalty = 1.1\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10565,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a random perturbation, scaling the edge usage, penalizing edges used in the local optimal tour, and sort the nodes based on the product of edge usage and the inverse of the total distance difference to find the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour\n    penalty = 1.1\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the inverse of the total distance difference\n    total_distance_diff = 1 / np.sum(np.abs(distance_matrix - new_distance_matrix), axis=1)\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage * total_distance_diff, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.13664,
          "other_inf": null
     }
}