{
     "parent1": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, the noise factor being a random value between -0.2 and 0.2, to increase the exploration space and escape from the local optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        noise_factor = np.random.uniform(-0.2, 0.2)  # Add random noise to the edge distance\n        updated_edge_distance[start_node][end_node] += noise_factor\n    \n    return updated_edge_distance",
          "objective": 0.47599,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Swap a pair of random edges along the local optimal route to create a perturbation in the edge distances, aiming to escape from the local optimum and explore new solutions.\n",
          "code": "import numpy as np\nimport random\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    idx1, idx2 = random.sample(range(len(local_opt_tour) - 1), 2)\n    start_node1, end_node1 = local_opt_tour[idx1], local_opt_tour[idx1 + 1]\n    start_node2, end_node2 = local_opt_tour[idx2], local_opt_tour[idx2 + 1]\n    \n    edge_index1 = edge_n_used[start_node1][end_node1]\n    edge_index2 = edge_n_used[start_node2][end_node2]\n    \n    updated_edge_distance[start_node1][end_node1], updated_edge_distance[start_node2][end_node2] = updated_edge_distance[start_node2][end_node2], updated_edge_distance[start_node1][end_node1]\n    \n    return updated_edge_distance",
          "objective": 2.28947,
          "other_inf": null
     }
}