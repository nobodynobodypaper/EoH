{
     "parent1": {
          "algorithm": "Create a new algorithm to identify the nodes with the highest impact on the edge usage, update the distance matrix based on the edge usage, and sort the nodes based on the impact for perturbation to avoid local optimum and minimize total distance.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Identify nodes with the highest impact on edge usage\n    impact_nodes = np.argmax(edge_n_used, axis=1)\n    \n    # Update distance matrix based on edge usage\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n    \n    # Sort nodes based on impact for perturbation\n    perturb_nodes = np.argsort(impact_nodes)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.17128,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix based on edge usage and sort the nodes based on a new score function for perturbation to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Identify nodes with the highest impact on edge usage\n    impact_nodes = np.argmax(edge_n_used, axis=1)\n    \n    # Update distance matrix based on a new score function for edge usage\n    new_distance_matrix = distance_matrix * (1 + edge_n_used**2)  # using a different score function - squaring the edge_n_used\n    \n    # Sort nodes based on impact for perturbation\n    perturb_nodes = np.argsort(impact_nodes)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.31563,
          "other_inf": null
     }
}