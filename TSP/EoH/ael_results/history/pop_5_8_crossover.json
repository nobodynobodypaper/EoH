{
     "parent1": {
          "algorithm": "The algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours. However, instead of directly sorting the nodes based on their impact, we will first create a priority queue where the priority is based on the impact value. Then, we will dequeue the top nodes from the priority queue to get the nodes to perturb.",
          "code": "import numpy as np\nimport heapq\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = []\n    for node, imp in enumerate(impact):\n        heapq.heappush(perturb_nodes, (imp, node))\n    \n    perturb_nodes = [node for _, node in perturb_nodes]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.937,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "The algorithm idea is to first calculate the impact of perturbing each node separately for the local optimal tour and the global optimal tour. Then, combine these impacts and sort the nodes based on their combined impact to find the top ones that should be perturbed. The impact calculation will be more efficient by avoiding redundant calculations.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    \n    for tour in [local_opt_tour, global_opt_tour]:\n        for i in range(len(tour) - 1):\n            new_distance_matrix[tour[i], tour[i+1]] += edge_n_used[tour[i], tour[i+1]]\n            new_distance_matrix[tour[i+1], tour[i]] += edge_n_used[tour[i+1], tour[i]]\n            \n            impact[tour[i]] += np.sum(new_distance_matrix[tour[i], :]) + np.sum(new_distance_matrix[:, tour[i]]) - new_distance_matrix[tour[i], tour[i]]\n            impact[tour[i+1]] += np.sum(new_distance_matrix[tour[i+1], :]) + np.sum(new_distance_matrix[:, tour[i+1]]) - new_distance_matrix[tour[i+1], tour[i+1]]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.067,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "The main idea of the new algorithm is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, similar to the first algorithm. However, instead of using a priority queue, we will utilize a different approach to sort the nodes based on their impact and find the top nodes to perturb.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    \n    for tour in [local_opt_tour, global_opt_tour]:\n        for i in range(len(tour) - 1):\n            new_distance_matrix[tour[i], tour[i+1]] += edge_n_used[tour[i], tour[i+1]]\n            new_distance_matrix[tour[i+1], tour[i]] += edge_n_used[tour[i+1], tour[i]]\n            \n            impact[tour[i]] += np.sum(new_distance_matrix[tour[i], :]) + np.sum(new_distance_matrix[:, tour[i]]) - new_distance_matrix[tour[i], tour[i]]\n            impact[tour[i+1]] += np.sum(new_distance_matrix[tour[i+1], :]) + np.sum(new_distance_matrix[:, tour[i+1]]) - new_distance_matrix[tour[i+1], tour[i+1]]\n    \n    perturb_nodes = np.argsort(impact)[::-1]  # Sort nodes in descending order based on impact\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.038,
          "first_obj": null
     }
}