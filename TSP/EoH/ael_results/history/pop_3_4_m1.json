{
     "parent1": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.ones_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    updated_edge_distance *= (1 + edge_count / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.24853,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution by reducing the distance of the frequently used edges.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += edge_n_used[start][end]\n        edge_count[end][start] += edge_n_used[end][start]\n\n    edge_count_normalized = edge_count / np.max(edge_count)\n    updated_edge_distance -= updated_edge_distance * edge_count_normalized\n\n    return updated_edge_distance",
          "objective": 3.49348,
          "other_inf": null
     }
}