{
     "parent1": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the proximity of each edge to the starting and ending nodes of the local optimal tour to guide the search towards a better solution by prioritizing edges closer to the starting and ending nodes.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    start_node = local_opt_tour[0]\n    end_node = local_opt_tour[-1]\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if i == start_node or j == start_node or i == end_node or j == end_node:\n                updated_edge_distance[i][j] = edge_distance[i][j] * 0.85\n\n    return updated_edge_distance",
          "objective": 3.45938,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    edge_count[edge_n_used == 0] = 1  # simplified to avoid overfitting\n\n    updated_edge_distance *= (1 + edge_count / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.20408,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, with the noise factor being a random value between -0.5 and 0.5, to escape from the local optimum and move towards a global optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        updated_edge_distance[start_node][end_node] += np.random.uniform(-0.5, 0.5)\n    \n    return updated_edge_distance",
          "objective": 0.24126,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nNew algorithm: Randomly shuffle the edges in the local optimal tour to break the pattern and explore new possibilities, while keeping the tour valid, to escape from the local optimum and improve the solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    local_opt_tour_edges = [(local_opt_tour[i], local_opt_tour[i+1]) for i in range(len(local_opt_tour)-1)]\n    np.random.shuffle(local_opt_tour_edges)\n    \n    for i in range(len(local_opt_tour_edges)):\n        start_node = local_opt_tour_edges[i][0]\n        end_node = local_opt_tour_edges[i][1]\n        edge_index = edge_n_used[start_node][end_node]\n        noise_factor = np.random.uniform(-0.5, 0.5)  # Add random noise to the edge distance\n        updated_edge_distance[start_node][end_node] += noise_factor\n    \n    return updated_edge_distance",
          "objective": 0.29281,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, with the noise factor being a random value between -0.5 and 0.5, to escape from the local optimum and move towards a global optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        updated_edge_distance[start_node][end_node] += np.random.uniform(-0.5, 0.5)\n    \n    return updated_edge_distance",
          "objective": 0.24126,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "New algorithm: Update the edge distances in the edge distance matrix based on the frequency of each edge in the local optimal tour, by decreasing the distance of more frequently used edges and increasing the distance of less frequently used edges to guide the search towards a better solution.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_frequency = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_frequency[start][end] += 1\n        edge_frequency[end][start] += 1\n\n    updated_edge_distance *= (1 + edge_frequency / np.max(edge_frequency))\n\n    return updated_edge_distance",
          "objective": 2.45101,
          "other_inf": null
     }
}