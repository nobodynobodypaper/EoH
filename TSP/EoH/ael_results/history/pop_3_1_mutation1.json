{
     "parent1": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb to avoid being trapped in the local optimum tour while also considering the impact on the global tour.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.997,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\n\nAlgorithm description: \nThe algorithm idea is to calculate the impact of each node on the local and global optimal tours, then update the distance matrix to consider the potential perturbation effect. Finally, sort the nodes based on their impact to find the top ones to perturb to avoid local optimum, considering the impact on the global tour as well.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Calculate impact of each node on local and global optimal tours\n    local_impact = np.sum(distance_matrix[local_opt_tour, :], axis=0) + np.sum(distance_matrix[:, local_opt_tour], axis=0) - distance_matrix[local_opt_tour, local_opt_tour]\n    global_impact = np.sum(distance_matrix[global_opt_tour, :], axis=0) + np.sum(distance_matrix[:, global_opt_tour], axis=0) - distance_matrix[global_opt_tour, global_opt_tour]\n\n    # Update distance matrix considering potential perturbation effect\n    new_distance_matrix = np.copy(distance_matrix)\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]] + local_impact[local_opt_tour[i]] + global_impact[local_opt_tour[i]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]] + local_impact[local_opt_tour[i+1]] + global_impact[local_opt_tour[i+1]]\n    \n    # Sort nodes based on impact to find top ones to perturb\n    impact = local_impact + global_impact\n    perturb_nodes = np.argsort(impact)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.422,
          "first_obj": null
     }
}