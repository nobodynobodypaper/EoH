{
     "parent2": {
          "algorithm": "\nThe algorithm will first update the distance matrix based on the local_opt_tour and edge_n_used, then it will calculate the potential impact of perturbing each node on the current tour by comparing the distances of alternate paths to the global_opt_tour, and finally, it will sort the nodes based on the potential impact to find the top nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    # Calculate potential impact of perturbing each node\n    potential_impact = np.zeros(len(local_opt_tour))\n    for i in range(len(local_opt_tour)):\n        if i == len(local_opt_tour) - 1:\n            edge = (local_opt_tour[i], local_opt_tour[0])\n        else:\n            edge = (local_opt_tour[i], local_opt_tour[i+1])\n        potential_impact[i] = new_distance_matrix[local_opt_tour[i]][local_opt_tour[i-1]] - distance_matrix[global_opt_tour[i]][local_opt_tour[i-1]]\n    \n    # Sort nodes based on potential impact\n    perturb_nodes = np.argsort(potential_impact)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.245,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description:\nThe algorithm first updates the distance matrix by considering both the local optimal tour and the global optimal tour. Then, it calculates the potential impact of perturbing each node based on the difference in distances between alternate paths to the local and global optimal tours. Finally, it sorts the nodes based on their potential impact and returns the updated distance matrix and the sorted nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix based on local and global optimal tours\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    for i in range(len(global_opt_tour) - 1):\n        edge = (global_opt_tour[i], global_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    # Calculate potential impact of perturbing each node\n    potential_impact = np.zeros(len(local_opt_tour))\n    for i in range(len(local_opt_tour)):\n        if i == len(local_opt_tour) - 1:\n            edge = (local_opt_tour[i], local_opt_tour[0])\n        else:\n            edge = (local_opt_tour[i], local_opt_tour[i+1])\n        potential_impact[i] = new_distance_matrix[local_opt_tour[i]][local_opt_tour[i-1]] - distance_matrix[global_opt_tour[i]][local_opt_tour[i-1]]\n    \n    # Sort nodes based on potential impact\n    perturb_nodes = np.argsort(potential_impact)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.255,
          "first_obj": null
     }
}