{
     "parent1": {
          "algorithm": "Create a new algorithm that updates the distance matrix by applying a combination of the inverse of the product of the local and global optimum tours, the exponential of the edge usage, and a random factor, then sorts the nodes based on the maximum inverse of the product of edge usage and minimum distance from the global optimum tour to determine the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_product_inverse = 1 / (local_opt_tour * global_opt_tour)\n    edge_usage_exp = np.exp(edge_n_used)\n    random_factor = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    \n    new_distance_matrix = distance_matrix + tour_product_inverse + edge_usage_exp * random_factor\n    perturb_nodes = np.argsort(np.maximum(1 / np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.2665,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm description: Create a new algorithm that updates the distance matrix by combining the square of the product of the local and global optimum tours, the logarithm of the edge usage, and a random factor, then sorts the nodes based on the minimum square of the product of edge usage and maximum distance from the global optimum tour to determine the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_product_square = (local_opt_tour * global_opt_tour)**2\n    edge_usage_log = np.log(edge_n_used + 1)  # adding 1 to avoid logarithm of 0\n    random_factor = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    \n    new_distance_matrix = distance_matrix + tour_product_square + edge_usage_log * random_factor\n    perturb_nodes = np.argsort(np.minimum((edge_n_used**2).sum(axis=1), np.max(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.14588,
          "other_inf": null
     }
}