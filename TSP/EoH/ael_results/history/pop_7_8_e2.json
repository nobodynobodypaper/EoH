{
     "parent1": {
          "algorithm": "Create a new algorithm that updates the distance matrix by incorporating a weighted average of the difference between local and global optimum tours and edge usage, and sorts the nodes based on the minimum distance from the global optimum tour and maximum edge usage to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a weighted average of the difference between local and global optimum tours and edge usage\n    new_distance_matrix = (0.6 * (local_opt_tour - global_opt_tour)) + (0.4 * edge_n_used) + distance_matrix\n    \n    # Sort the nodes based on the minimum distance from the global optimum tour and maximum edge usage\n    perturb_nodes = np.argsort(np.maximum(np.min(new_distance_matrix, axis=1), np.max(edge_n_used, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.06466,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix based on the local optimum tour, global optimum tour, and edge usage by implementing a unique scoring function, and then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different scoring function incorporating local optimum, global optimum, and edge usage\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) + (local_opt_tour - global_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)  # random perturbation\n\n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08595,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "Create a new algorithm that updates the distance matrix by multiplying each edge with a random number, penalizes edges used in the local optimal tour by subtracting a penalty value, and sorts the nodes based on the total distance difference and the minimum edge usage.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by multiplying each edge with a random number\n    random_multiplier = np.random.uniform(0.7, 1.3, size=distance_matrix.shape)\n    new_distance_matrix = distance_matrix * random_multiplier\n    \n    # Penalize edges used in the local optimal tour\n    penalty = 0.9\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] -= penalty\n    \n    # Sort the nodes based on the total distance difference and the minimum edge usage\n    total_distance_difference = np.sum(np.abs(new_distance_matrix - distance_matrix), axis=1)\n    combined_metric = total_distance_difference + np.min(edge_n_used, axis=1)\n    perturb_nodes = np.argsort(combined_metric)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 3.49348,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "Create an algorithm that updates the distance matrix by incorporating a weighted average of the difference between local and global optimum tours, edge usage, and randomness, and sorts the nodes based on a combination of minimum distance from the global optimum tour and maximum edge usage to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a weighted average of the difference between local and global optimum tours, edge usage, and randomness\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = (0.6 * (local_opt_tour - global_opt_tour)) + (0.3 * edge_n_used) + (0.1 * randomness) + distance_matrix\n    \n    # Sort the nodes based on a combination of maximum distance from the global optimum tour and minimum edge usage\n    weighted_distance = 0.4 * np.min(new_distance_matrix, axis=1) + 0.6 * np.max(edge_n_used, axis=1)\n    perturb_nodes = np.argsort(weighted_distance)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.07567,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "Create a new algorithm that updates the distance matrix by multiplying each edge with a random number, penalizes edges used in the local optimal tour by subtracting a penalty value, and sorts the nodes based on the total distance difference and the minimum edge usage.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by multiplying each edge with a random number\n    random_multiplier = np.random.uniform(0.7, 1.3, size=distance_matrix.shape)\n    new_distance_matrix = distance_matrix * random_multiplier\n    \n    # Penalize edges used in the local optimal tour\n    penalty = 0.9\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] -= penalty\n    \n    # Sort the nodes based on the total distance difference and the minimum edge usage\n    total_distance_difference = np.sum(np.abs(new_distance_matrix - distance_matrix), axis=1)\n    combined_metric = total_distance_difference + np.min(edge_n_used, axis=1)\n    perturb_nodes = np.argsort(combined_metric)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 3.49348,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix by incorporating a combination of edge weights, penalties for edge usage in the local optimum tour, and random perturbations, and sorts the nodes based on a unique scoring function to find the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a combination of edge weights, penalties, and random perturbations\n    weighted_distance_matrix = distance_matrix * np.random.uniform(0.7, 1.3, size=distance_matrix.shape)\n    penalty = 0.9\n    for i in range(len(local_opt_tour)-1):\n        weighted_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] -= penalty\n    new_distance_matrix = weighted_distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n\n    # Sort the nodes using a unique scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 2.03424,
          "other_inf": null
     }
}