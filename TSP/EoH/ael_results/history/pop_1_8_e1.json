{
     "parent1": {
          "algorithm": "\nNew algorithm: Identify the least frequently used edges in the local optimal tour and update their distances in the edge distance matrix to encourage exploration of different routes, while also randomizing the distances of non-participating edges to promote diversification in the search for a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    min_used_edge = np.argmin(edge_n_used)\n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n        if edge_n_used[start][end] < np.mean(edge_n_used):  # Update distances of least frequently used edges\n            updated_edge_distance[start][end] *= (1 - edge_n_used[start][end]/min_used_edge)\n            updated_edge_distance[end][start] *= (1 - edge_n_used[end][start]/min_used_edge)\n        else:  # Randomly perturb the distances of non-participating edges\n            perturbation_factor = np.random.uniform(0.9, 1.1)\n            updated_edge_distance[start][end] *= perturbation_factor\n            updated_edge_distance[end][start] *= perturbation_factor\n    return updated_edge_distance",
          "objective": 2.67133,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution.\n",
          "code": "import numpy as np\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] *= (1 + edge_count[i][j] / (edge_n_used[i][j] + 1))\n    return updated_edge_distance",
          "objective": 1.12469,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] *= (1 + edge_count[i][j] / edge_n_used[i][j])\n\n    return updated_edge_distance",
          "objective": 0.65616,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] *= (1 + edge_count[i][j] / edge_n_used[i][j])\n\n    return updated_edge_distance",
          "objective": 0.65616,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nThe new algorithm will update the edge distance matrix by identifying and prioritizing the least used edges in the local optimal tour, decreasing their distances to encourage further exploration of those paths, while increasing the distances of heavily used edges to discourage revisiting them.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] == 0:\n                updated_edge_distance[i][j] *= 0.9  # Decrease distance of least used edges\n            else:\n                updated_edge_distance[i][j] *= 1.1  # Increase distance of heavily used edges\n\n    return updated_edge_distance",
          "objective": 2.82733,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges that deviate the most from the average distance and update their distances in the edge distance matrix to encourage exploration of alternative routes, while also adjusting the distances of other edges based on their deviation from the average distance to promote diversification in the search for a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    avg_distance = np.mean(edge_distance)\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_distance[i][j] < avg_distance:  # Decrease distance of edges that are below average\n                updated_edge_distance[i][j] *= 0.9\n            elif edge_distance[i][j] > avg_distance:  # Increase distance of edges that are above average\n                updated_edge_distance[i][j] *= 1.1\n            else:  # Randomly perturb the distances of edges that are equal to the average\n                perturbation_factor = np.random.uniform(0.9, 1.1)\n                updated_edge_distance[i][j] *= perturbation_factor\n\n    return updated_edge_distance",
          "objective": 3.49348,
          "other_inf": null
     }
}