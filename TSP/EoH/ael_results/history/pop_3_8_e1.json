{
     "parent1": {
          "algorithm": "New algorithm: Update the edge distances in the edge distance matrix based on the frequency of each edge used in the local optimal tour and the edge distance to guide the search towards a better solution.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] += np.log(edge_count[i][j] + 1) / np.log(2) * (1 / max(edge_n_used[i][j], 1))\n\n    return updated_edge_distance",
          "objective": 0.16233,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "The new algorithm uses a scaling factor that inversely depends on the square root of the edge count to update the edge distances in the edge distance matrix.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                scaling_factor = np.sqrt(edge_count[i][j])  # scaling factor based on edge count\n                noise_factor = np.random.uniform(-0.5 / scaling_factor, 0.5 / scaling_factor)\n                updated_edge_distance[i][j] += noise_factor\n\n    return updated_edge_distance",
          "objective": 0.10604,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "Update the edge distances in the edge distance matrix based on frequency of each edge used in the local optimal tour using a modified noise factor that depends on the edge count to guide the search towards a better solution",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                noise_factor = np.random.uniform(-0.5 / edge_count[i][j], 0.5 / edge_count[i][j])\n                updated_edge_distance[i][j] += noise_factor\n\n    return updated_edge_distance",
          "objective": 0.09253,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "Update the edge distances in the edge distance matrix based on frequency of each edge used in the local optimal tour using a modified noise factor that depends on the edge count to guide the search towards a better solution",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                noise_factor = np.random.uniform(-0.5 / edge_count[i][j], 0.5 / edge_count[i][j])\n                updated_edge_distance[i][j] += noise_factor\n\n    return updated_edge_distance",
          "objective": 0.09253,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, the noise factor being a random value between -0.5 and 0.5, to increase the exploration space and escape from the local optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        noise_factor = np.random.uniform(-0.5, 0.5)  # Add random noise to the edge distance\n        updated_edge_distance[start_node][end_node] += noise_factor\n    \n    return updated_edge_distance",
          "objective": 0.22699,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the difference between the frequency of each edge used in the local optimal tour and the average edge usage, with a modification factor calculated using the product of edge count and distance to guide the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n    edge_avg = np.sum(edge_n_used) / np.count_nonzero(edge_n_used)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                modification_factor = edge_count[i][j] * edge_distance[i][j]\n                updated_edge_distance[i][j] += np.log(edge_count[i][j] + 1) / np.log(2) * (1 / (max(edge_n_used[i][j], 1) - edge_avg)) * modification_factor\n\n    return updated_edge_distance",
          "objective": 3.05792,
          "other_inf": null
     }
}