{
     "parent2": {
          "algorithm": "\nThe algorithm first calculates the difference between the local optimal tour and the global optimal tour, updates the distance matrix based on the edges used in the local optimal tour and number of times each edge is used, and then identifies the nodes that cause the biggest difference in the tours. Finally, it sorts the nodes based on the differences and returns the updated distance matrix and the sorted nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    difference = np.abs(local_opt_tour - global_opt_tour)  # Calculate the difference between local and global tours\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)  # Update distance matrix based on edges used and number of times each edge is used\n    perturb_nodes = np.argsort(difference)[::-1]  # Sort nodes based on difference in descending order\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.436,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe algorithm first calculates the overall difference between the local optimal tour and the global optimal tour, then updates the distance matrix based on the edges used in the local optimal tour and the number of times each edge is used. After that, it identifies the nodes that contribute the most to the difference in tours by considering the impact of each node, and finally, sorts the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    overall_difference = np.abs(local_opt_tour - global_opt_tour)  # Calculate the overall difference\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)  # Update distance matrix based on edges used and number of times each edge is used\n    impact = np.sum(new_distance_matrix, axis=1)  # Calculate the impact of each node based on the updated distance matrix\n    perturb_nodes = np.argsort(impact)[::-1]  # Sort nodes based on impact in descending order\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.486,
          "first_obj": null
     }
}