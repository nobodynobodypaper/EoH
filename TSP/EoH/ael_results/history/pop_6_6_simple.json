{
     "parent1": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix and sort the nodes for perturbation based on a unique combination of the local optimum tour, global optimum tour, edge usage, and random perturbation to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a unique combination of local optimum, global optimum, edge usage, and random perturbation\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) + (local_opt_tour - global_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n\n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.min(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.16148,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix and sort the nodes for perturbation based on a unique combination of the local optimum tour, global optimum tour, edge usage, and random perturbation to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a unique combination of local optimum, global optimum, edge usage, and random perturbation\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) + (local_opt_tour - global_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n\n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.min(new_distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape), axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.16923,
          "other_inf": null
     }
}