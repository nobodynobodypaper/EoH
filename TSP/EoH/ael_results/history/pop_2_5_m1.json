{
     "parent1": {
          "algorithm": "Update the distance matrix by multiplying the edge usage with a factor of 5, subtract the element-wise difference between the global optimum tour and the local optimum tour from the distance matrix, and then sort the nodes based on the total distance difference to find the top ones to perturb.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + np.multiply(edge_n_used, 5)\n    perturb_nodes = np.argsort(global_opt_tour - local_opt_tour)[::-1]\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.18493,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix and sort the top nodes to perturb by adding a random noise to the distance matrix proportional to the edge usage, subtracting the element-wise difference between the global optimum tour and the local optimum tour, and then sorting the nodes based on the total distance difference.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    noise = np.random.random(distance_matrix.shape) * edge_n_used\n    new_distance_matrix = distance_matrix + noise\n    perturb_nodes = np.argsort(global_opt_tour - local_opt_tour)[::-1]\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.15859,
          "other_inf": null
     }
}