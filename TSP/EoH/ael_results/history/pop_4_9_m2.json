{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a random perturbation, scaling the edge usage, penalizing edges used in the local optimal tour, and sorting the nodes based on the product of edge usage and the total distance difference to find the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour\n    penalty = 1.1\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10565,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a random perturbation, scaling the edge usage, penalizing edges used in the local optimum tour, and sorting the nodes based on the sum of edge usage and the total distance difference to find the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * 3  # Increase scaling factor for edge usage\n    \n    # Penalize edges used in the local optimal tour\n    penalty = 1.2  # Increase penalty for edges in local optimal tour\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the sum of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix + scaled_edge_usage, axis=1))  # Change how nodes are sorted\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10614,
          "other_inf": null
     }
}