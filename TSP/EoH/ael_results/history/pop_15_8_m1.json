{
     "parent1": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by using a combination of the difference between the local and global optimum tours, edge usage, and a heuristic function, and then sorts the nodes based on the heuristic function to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by using a combination of the difference between local and global optimum tours, edge usage, and a heuristic function\n    heuristic_function = np.sin(distance_matrix) + np.cos(local_opt_tour) - np.tan(global_opt_tour)\n    new_distance_matrix = 0.6 * (local_opt_tour - global_opt_tour) + 0.3 * edge_n_used + 0.1 * heuristic_function + distance_matrix\n    \n    # Sort the nodes based on the heuristic function\n    weighted_heuristic = np.argsort(np.max(heuristic_function, axis=1))\n    perturb_nodes = np.argsort(weighted_heuristic)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.18454,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by using a combination of the difference between the local and global optimum tours, edge usage, and a different heuristic function, and then sorts the nodes based on the updated heuristic function to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by using a combination of the difference between local and global optimum tours, edge usage, and a different heuristic function\n    updated_heuristic_function = np.sin(distance_matrix) + np.cos(local_opt_tour) - np.tan(global_opt_tour) + np.exp(-distance_matrix)\n    new_distance_matrix = 0.5 * (local_opt_tour - global_opt_tour) + 0.4 * edge_n_used + 0.1 * updated_heuristic_function + distance_matrix\n\n    # Sort the nodes based on the updated heuristic function\n    weighted_updated_heuristic = np.argsort(np.max(updated_heuristic_function, axis=1))\n    perturb_nodes = np.argsort(weighted_updated_heuristic)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.23158,
          "other_inf": null
     }
}