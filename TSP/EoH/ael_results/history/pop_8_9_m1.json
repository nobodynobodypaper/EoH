{
     "parent1": {
          "algorithm": "Update the edge distances in the edge distance matrix by applying a dynamic weight factor that adjusts based on edge count, distance, and usage, with the intention of balancing exploration and exploitation for improved search performance.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_count = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n    \n    edge_n_used_max = np.max(edge_n_used)\n    mean_edge_distance = np.mean(edge_distance)\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                weight_factor = (np.random.uniform(0.7, 1.3) / edge_count[i][j]) + (edge_distance[i][j] / mean_edge_distance) - (0.3 / edge_n_used_max) * edge_n_used[i][j]\n                updated_edge_distance[i][j] += weight_factor * (1 + edge_count[i][j])\n\n    return updated_edge_distance",
          "objective": 0.02171,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm dynamically adjusts the edge distances in the matrix based on the usage and visit frequency of edges in the local optimal tour, aiming to avoid local optima and find a tour with minimized distance.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_visit_frequency = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_visit_frequency[start][end] += 1\n        edge_visit_frequency[end][start] += 1\n    \n    edge_n_used_max = np.max(edge_n_used)\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_visit_frequency[i][j] > 0:\n                usage_factor = edge_n_used[i][j] / edge_n_used_max\n                updated_edge_distance[i][j] += (1 + usage_factor) / edge_visit_frequency[i][j]\n\n    return updated_edge_distance",
          "objective": 1.87561,
          "other_inf": null
     }
}