{
     "parent1": {
          "algorithm": "\nThe new algorithm will first update the distance matrix by adding a penalty to the edges used in the local_opt_tour and global_opt_tour based on the number of times the edge is used in the edge_n_used matrix. Then, it will sort the nodes based on the sum of the penalty and the number of times the edge is used, and return the top nodes to perturb to avoid being trapped in a local optimum tour.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    penalty = 1000  # Penalty for the edges used in the local_opt_tour and global_opt_tour\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        from_node = local_opt_tour[i]\n        to_node = local_opt_tour[i+1]\n        new_distance_matrix[from_node][to_node] += penalty * edge_n_used[from_node][to_node]\n        new_distance_matrix[to_node][from_node] += penalty * edge_n_used[to_node][from_node]\n    \n    for i in range(len(global_opt_tour) - 1):\n        from_node = global_opt_tour[i]\n        to_node = global_opt_tour[i+1]\n        new_distance_matrix[from_node][to_node] += penalty * edge_n_used[from_node][to_node]\n        new_distance_matrix[to_node][from_node] += penalty * edge_n_used[to_node][from_node]\n    \n    edge_penalty_sum = np.sum(new_distance_matrix, axis=1) + np.sum(edge_n_used, axis=1)  # Sort based on edge penalty sum and number of times the edge is used\n    perturb_nodes = np.argsort(-edge_penalty_sum)  # Sort nodes based on edge penalty sum in descending order\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.257,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "\nThe algorithm will first update the distance matrix based on the local_opt_tour and edge_n_used, then it will calculate the potential impact of perturbing each node on the current tour by comparing the distances of alternate paths to the global_opt_tour, and finally, it will sort the nodes based on the potential impact to find the top nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    # Calculate potential impact of perturbing each node\n    potential_impact = np.zeros(len(local_opt_tour))\n    for i in range(len(local_opt_tour)):\n        if i == len(local_opt_tour) - 1:\n            edge = (local_opt_tour[i], local_opt_tour[0])\n        else:\n            edge = (local_opt_tour[i], local_opt_tour[i+1])\n        potential_impact[i] = new_distance_matrix[local_opt_tour[i]][local_opt_tour[i-1]] - distance_matrix[global_opt_tour[i]][local_opt_tour[i-1]]\n    \n    # Sort nodes based on potential impact\n    perturb_nodes = np.argsort(potential_impact)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.245,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: The new algorithm will first update the distance matrix based on the local_opt_tour and edge_n_used by adding a penalty, then it will calculate the average distance of alternate paths from each node to the global_opt_tour, and finally, it will sort the nodes based on the average distance to find the top nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    penalty = 1000  # Penalty for the edges used in the local_opt_tour\n    new_distance_matrix = distance_matrix.copy()\n    \n    # Update distance matrix with penalty\n    for i in range(len(local_opt_tour) - 1):\n        from_node = local_opt_tour[i]\n        to_node = local_opt_tour[i+1]\n        new_distance_matrix[from_node][to_node] += penalty * edge_n_used[from_node][to_node]\n        new_distance_matrix[to_node][from_node] += penalty * edge_n_used[to_node][from_node]\n    \n    # Calculate average distance of alternate paths from each node to the global_opt_tour\n    avg_distance = np.zeros(len(local_opt_tour))\n    for i in range(len(local_opt_tour)):\n        alt_paths = [new_distance_matrix[local_opt_tour[i]][node] for node in global_opt_tour]\n        avg_distance[i] = np.mean(alt_paths)\n    \n    # Sort nodes based on average distance\n    perturb_nodes = np.argsort(avg_distance)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.63,
          "first_obj": null
     }
}