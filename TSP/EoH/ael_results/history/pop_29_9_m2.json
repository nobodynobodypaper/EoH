{
     "parent1": {
          "algorithm": "new_distance_matrix, perturb_nodes",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference = (local_opt_tour - global_opt_tour) ** 2\n    average_edge_usage = np.mean(edge_n_used, axis=1)\n    weighted_factor = 0.5 \n    inverse_distance_matrix = 1 / (distance_matrix + 1)\n    \n    new_distance_matrix = distance_matrix + (tour_difference + average_edge_usage * np.random.rand(distance_matrix.shape[0]) + inverse_distance_matrix) * weighted_factor\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.max(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.04594,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\n  New algorithm description: \n  Create a new distance matrix based on the weighted sum of tour difference, average edge usage, and a modified inverse distance matrix, then sort the nodes to perturb based on the maximum value of the product of edge usage and the new distance matrix.\n\n  Python function:\n  import numpy as np\n\n  def get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n      tour_difference = (local_opt_tour - global_opt_tour) ** 3\n      average_edge_usage = np.mean(edge_n_used, axis=1)\n      weighted_factor = 0.7 \n      modified_inverse_distance_matrix = 1 / (distance_matrix + 2)\n      \n      new_distance_matrix = distance_matrix + (tour_difference + average_edge_usage * np.random.rand(distance_matrix.shape[0]) + modified_inverse_distance_matrix) * weighted_factor\n      perturb_nodes = np.argsort(np.maximum(edge_n_used.sum(axis=1), new_distance_matrix.max(axis=1)))\n      \n      return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\n  def get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n      tour_difference = (local_opt_tour - global_opt_tour) ** 3\n      average_edge_usage = np.mean(edge_n_used, axis=1)\n      weighted_factor = 0.7 \n      modified_inverse_distance_matrix = 1 / (distance_matrix + 2)\n      \n      new_distance_matrix = distance_matrix + (tour_difference + average_edge_usage * np.random.rand(distance_matrix.shape[0]) + modified_inverse_distance_matrix) * weighted_factor\n      perturb_nodes = np.argsort(np.maximum(edge_n_used.sum(axis=1), new_distance_matrix.max(axis=1)))\n      \n      return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}