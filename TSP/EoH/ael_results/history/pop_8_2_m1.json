{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix based on the combination of local and global optimum tours, edge usage, and a unique randomness factor, and then sorts the nodes using a scoring function that considers the difference between local and global optimum tours and the maximum edge usage to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on the combination of local and global optimum tours, edge usage, and randomness\n    unique_randomness = np.random.uniform(-1, 1, size=distance_matrix.shape)\n    new_distance_matrix = distance_matrix + (0.6 * (local_opt_tour - global_opt_tour)) + (0.4 * edge_n_used) + unique_randomness\n    \n    # Sort the nodes using a scoring function considering the difference between local and global optimum tours and maximum edge usage\n    perturb_nodes = np.argsort(np.maximum((local_opt_tour - global_opt_tour), np.max(edge_n_used, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08262,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix based on the combination of local and global optimum tours, edge usage, and a unique randomness factor by applying a weighted average using different coefficients, and then sorts the nodes using a scoring function that considers the difference between local and global optimum tours and the maximum edge usage to identify the top nodes for perturbation with the goal of finding a tour with minimized total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on the combination of local and global optimum tours, edge usage, and a unique randomness factor\n    unique_randomness = np.random.uniform(-1, 1, size=distance_matrix.shape)\n    new_distance_matrix = distance_matrix * 0.4 + (local_opt_tour - global_opt_tour) * 0.3 + edge_n_used * 0.3 + unique_randomness\n    \n    # Sort the nodes using a scoring function considering the difference between local and global optimum tours and maximum edge usage\n    perturb_nodes = np.argsort((local_opt_tour - global_opt_tour) + np.max(edge_n_used, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.16102,
          "other_inf": null
     }
}