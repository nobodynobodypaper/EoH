{
     "parent1": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution with a more aggressive update by squaring the edge count.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.ones_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    updated_edge_distance *= (1 + (edge_count ** 2) / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.18055,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution with a more aggressive update by squaring the edge count.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.ones_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    updated_edge_distance *= (1 + (edge_count ** 2) / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.18055,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, the noise factor being a random value between -0.5 and 0.5, to increase the exploration space and escape from the local optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        noise_factor = np.random.uniform(-0.5, 0.5)  # Add random noise to the edge distance\n        updated_edge_distance[start_node][end_node] += noise_factor\n    \n    return updated_edge_distance",
          "objective": 0.22699,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    edge_count[edge_n_used == 0] = 1  # simplified to avoid overfitting\n\n    updated_edge_distance *= (1 + edge_count / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.20408,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are frequently used and update their distances in the edge distance matrix to discourage using them again, thereby guiding the search towards a better solution with a more aggressive update by squaring the edge count.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.ones_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    updated_edge_distance *= (1 + (edge_count ** 2) / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.18055,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are least frequently used and update their distances in the edge distance matrix to encourage using them more, thereby guiding the search towards a better solution by promoting unexplored edges.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.ones_like(edge_distance) * np.amax(edge_n_used)  # Initialize edge_count with maximum edge usage\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] = edge_n_used[start][end]  # Update edge_count with actual edge usage\n\n    updated_edge_distance /= (1 + edge_count / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.24818,
          "other_inf": null
     }
}