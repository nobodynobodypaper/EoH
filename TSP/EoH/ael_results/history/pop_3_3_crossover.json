{
     "parent1": {
          "algorithm": "\n\nAlgorithm description: \nThe new algorithm idea is to create a new distance matrix based on the local optimal tour, global optimal tour, and number of times each edge is used. Then, it will identify the most critical nodes to perturb based on the edges with the highest usage in the updated distance matrix. In contrast to the previous algorithms, this approach aims to prioritize perturbation based on the impact of edge usage on the distance matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Create new distance matrix based on local optimal tour, global optimal tour, and edge usage\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n\n    # Identify perturb nodes based on edges with highest usage in updated distance matrix\n    perturb_nodes = np.argsort(-edge_n_used.sum(axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.326,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "\nAlgorithm description: \nThe algorithm will first identify the edges that are part of the local optimal tour and update the distance matrix by increasing the distances of these edges based on their utilization using edge_n_used. Then, it will calculate the potential impact of perturbing each node by evaluating the reduction in the total distance if that node is perturbed. Finally, it will sort the nodes based on their potential impact and return the updated distance matrix and the sorted nodes to perturb.\n\nCode:\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    edges_in_local_opt_tour = np.zeros(distance_matrix.shape)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edges_in_local_opt_tour[start][end] = edge_n_used[start][end]\n        edges_in_local_opt_tour[end][start] = edge_n_used[end][start]\n\n    new_distance_matrix = distance_matrix + edges_in_local_opt_tour\n    perturb_impact = np.sum(edge_n_used * (distance_matrix - new_distance_matrix), axis=1)\n    perturb_nodes = np.argsort(perturb_impact)[::-1]\n\n    return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    edges_in_local_opt_tour = np.zeros(distance_matrix.shape)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edges_in_local_opt_tour[start][end] = edge_n_used[start][end]\n        edges_in_local_opt_tour[end][start] = edge_n_used[end][start]\n\n    new_distance_matrix = distance_matrix + edges_in_local_opt_tour\n    perturb_impact = np.sum(edge_n_used * (distance_matrix - new_distance_matrix), axis=1)\n    perturb_nodes = np.argsort(perturb_impact)[::-1]\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.728,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm idea is to identify the edges with the highest usage in the distance matrix and prioritize perturbation based on their impact on the overall tour distance. First, create a new distance matrix by updating the distances of edges based on their utilization, and then sort the nodes based on the impact of perturbing each node on the total distance to find the top nodes to perturb. \n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Identify edges with highest usage and update distance matrix\n    max_used_edges = np.where(edge_n_used == np.max(edge_n_used))\n    updated_distances = distance_matrix.copy()\n    for edge in zip(max_used_edges[0], max_used_edges[1]):\n        updated_distances[edge[0], edge[1]] *= (1 + edge_n_used[edge[0], edge[1]])\n        updated_distances[edge[1], edge[0]] *= (1 + edge_n_used[edge[1], edge[0]])\n\n    # Sort nodes based on potential impact on total distance and return updated distance matrix and sorted nodes to perturb\n    perturb_impact = np.sum(edge_n_used * (distance_matrix - updated_distances), axis=1)\n    perturb_nodes = np.argsort(perturb_impact)[::-1]\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}