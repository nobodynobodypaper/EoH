{
     "parent1": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix based on the edges used in the local optimum tour, then calculate the impact of perturbing each node on the total distance, and finally sort the nodes based on their impact to find the top ones to perturb to avoid being trapped in the local optimum tour.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for node in range(distance_matrix.shape[0]):\n        if node not in local_opt_tour:\n            temp_local_opt_tour = local_opt_tour.copy()\n            for i in range(len(temp_local_opt_tour)):\n                temp_local_opt_tour[i] = node\n                impact[node] += calculate_total_distance(new_distance_matrix, temp_local_opt_tour)\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.554,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe algorithm calculates the impact of perturbing each node on the total distance by first updating the distance matrix based on the edges used in the local optimum tour and the difference in distance between the local optimum tour and the global optimum tour. Then, it sorts the nodes based on their impact to find the top ones to perturb in order to avoid being trapped in the local optimum tour. \n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    # Update the distance matrix based on the edges used in the local optimum tour\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n    \n    # Calculate the difference in distance for each edge between the local optimum tour and the global optimum tour\n    edge_diff = np.abs(new_distance_matrix - local_opt_tour + global_opt_tour)\n    \n    # Update the distance matrix based on the difference in distance\n    new_distance_matrix += edge_diff\n    \n    # Calculate the impact of perturbing each node on the total distance\n    impact = np.zeros(distance_matrix.shape[0])\n    for node in range(distance_matrix.shape[0]):\n        if node not in local_opt_tour:\n            temp_local_opt_tour = local_opt_tour.copy()\n            for i in range(len(temp_local_opt_tour)):\n                temp_local_opt_tour[i] = node\n                impact[node] += calculate_total_distance(new_distance_matrix, temp_local_opt_tour)\n    \n    # Sort the nodes based on their impact to find the top ones to perturb\n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.554,
          "first_obj": null
     }
}