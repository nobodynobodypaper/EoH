{
     "parent1": {
          "algorithm": "\nThe algorithm will first update the distance matrix based on the local optimal tour, global optimal tour, and the number of times each edge is used. Then, it will sort the nodes based on some heuristic to provide the top nodes to perturb in order to avoid being trapped in the local optimum tour.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n    \n    # Sort nodes based on some heuristic\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.56,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "\nThe algorithm idea is to first identify the edges that are not part of the local optimal tour and update the distance matrix by subtracting a penalty from these edges. Then, it calculates the potential impact of perturbing each node by considering the reduction in the total distance if that node is perturbed. Finally, it sorts the nodes based on their potential impact and returns the updated distance matrix and the sorted nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    edges_not_in_local_opt_tour = np.ones(distance_matrix.shape)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edges_not_in_local_opt_tour[start][end] = 0\n        edges_not_in_local_opt_tour[end][start] = 0\n\n    new_distance_matrix = distance_matrix - edges_not_in_local_opt_tour\n    perturb_impact = np.sum(edge_n_used * (distance_matrix - new_distance_matrix), axis=1)\n    perturb_nodes = np.argsort(perturb_impact)[::-1]\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.745,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: \nThe algorithm will first identify the edges that are part of the local optimal tour but not the global optimal tour, and then update the distance matrix by adding a penalty to these edges. After that, it will sort the nodes based on the potential impact of perturbing each node, which is calculated by considering the increase in the total distance if that node is perturbed.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    edges_not_in_global_opt_tour = np.ones(distance_matrix.shape)\n    for i in range(len(global_opt_tour) - 1):\n        start = global_opt_tour[i]\n        end = global_opt_tour[i + 1]\n        edges_not_in_global_opt_tour[start][end] = 0\n        edges_not_in_global_opt_tour[end][start] = 0\n\n    new_distance_matrix = distance_matrix + edges_not_in_global_opt_tour\n    perturb_impact = np.sum(edge_n_used * (new_distance_matrix - distance_matrix), axis=1)\n    perturb_nodes = np.argsort(perturb_impact)[::-1]\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 4.301,
          "first_obj": null
     }
}