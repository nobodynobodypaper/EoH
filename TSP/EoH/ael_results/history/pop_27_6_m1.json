{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by applying a transformation to the difference between the local and global optimum tours, multiplying it by the sum of the edge usage and a random factor, and then sorting the nodes based on the maximum distance from the global optimum tour and minimum edge usage to determine the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference_transformed = np.sqrt(np.abs(local_opt_tour - global_opt_tour))  # Apply a transformation to the tour difference\n    edge_usage_sum = np.sum(edge_n_used, axis=1)\n    random_factor = np.random.rand(distance_matrix.shape[0])\n    \n    new_distance_matrix = distance_matrix + (tour_difference_transformed * (edge_usage_sum + random_factor))\n    perturb_nodes = np.argsort(np.minimum(np.min(edge_n_used, axis=1), np.max(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.49348,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by applying a modified transformation to the difference between the local and global optimum tours, considering both the edge usage and distance, and then sorting the nodes based on the maximum distance from the global optimum tour and minimum edge usage to determine the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference_transformed = np.abs(local_opt_tour - global_opt_tour) ** 2  # Apply a modified transformation to the tour difference\n    edge_usage_sum = np.sum(edge_n_used, axis=1)\n    distance_sum = np.sum(distance_matrix, axis=1)  # Calculate the sum of distances for each node\n    combined_factor = (tour_difference_transformed + edge_usage_sum) * distance_sum  # Combine the edge usage and distance factors\n    new_distance_matrix = distance_matrix + combined_factor[:, None]  # Update the distance matrix with the combined factor\n    perturb_nodes = np.argsort(np.vstack([np.max(new_distance_matrix, axis=1), np.min(edge_n_used, axis=1)])).T[:,::-1]  # Sort the nodes based on maximum distance and minimum edge usage\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}