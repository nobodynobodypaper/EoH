{
     "parent1": {
          "algorithm": "Create a new algorithm that updates the distance matrix by calculating the weighted sum of the product of the edge usage and the difference between local and global optimum tours, adds randomness, and sorts the nodes based on the maximum edge usage and minimum distance from the global optimum tour.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    weighted_sum = (0.5 * edge_n_used * (local_opt_tour - global_opt_tour)) + (0.2 * np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1]))\n    new_distance_matrix = distance_matrix + weighted_sum\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.28406,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm description: Create a modified algorithm that updates the distance matrix by incorporating the difference between local and global optimum tours, adds randomness, and sorts the nodes based on the maximum edge usage and minimum distance from the global optimum tour.\n\nCode:\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    weighted_sum = (0.5 * (local_opt_tour - global_opt_tour)) + (0.2 * np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1]))\n    new_distance_matrix = distance_matrix + weighted_sum\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.30892,
          "other_inf": null
     }
}