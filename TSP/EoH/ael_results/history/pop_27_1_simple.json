{
     "parent1": {
          "algorithm": "\nNew algorithm: Create a novel algorithm that updates the distance matrix by incorporating a weighted combination of edge usage, the difference between local and global optimum tours, and a customized randomness, and then sorts the nodes based on this metric to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    edge_usage_weight = 0.2\n    tour_difference_weight = 0.4\n    randomness_weight = 0.4\n    \n    custom_metric = (edge_usage_weight * (edge_n_used / np.max(edge_n_used))) + (tour_difference_weight * (local_opt_tour - global_opt_tour)) + (randomness_weight * np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1]))\n    new_distance_matrix = distance_matrix + custom_metric\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08242,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Create a novel algorithm that updates the distance matrix by incorporating a weighted combination of edge usage, the difference between local and global optimum tours, and a customized randomness, and then sorts the nodes based on this metric to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    custom_metric = calculate_custom_metric(local_opt_tour, global_opt_tour, distance_matrix, edge_n_used)\n    new_distance_matrix = update_distance_matrix(distance_matrix, custom_metric)\n    perturb_nodes = sort_perturb_nodes(new_distance_matrix, edge_n_used)\n    \n    return new_distance_matrix, perturb_nodes\n\ndef calculate_custom_metric(local_opt_tour, global_opt_tour, distance_matrix, edge_n_used):\n    edge_usage_weight = 0.2\n    tour_difference_weight = 0.4\n    randomness_weight = 0.4\n    \n    custom_metric = (edge_usage_weight * (edge_n_used / np.max(edge_n_used))) + (tour_difference_weight * (local_opt_tour - global_opt_tour)) + (randomness_weight * np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1]))\n    return custom_metric\n\ndef update_distance_matrix(distance_matrix, custom_metric):\n    new_distance_matrix = distance_matrix + custom_metric\n    return new_distance_matrix\n\ndef sort_perturb_nodes(new_distance_matrix, edge_n_used):\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}