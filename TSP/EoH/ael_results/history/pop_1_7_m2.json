{
     "parent1": {
          "algorithm": "\nThe new algorithm involves identifying edges that are heavily used in the local optimal tour and updating their distance in the edge distance matrix to prioritize less frequently used edges, thus promoting exploration of different routes, while scaling the update factor by the inverse of the edge's usage frequency.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    max_used_edge = np.max(edge_n_used)\n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n        updated_edge_distance[start][end] *= (1 + 1/(edge_n_used[start][end]+1))\n    return updated_edge_distance",
          "objective": 1.84289,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm involves identifying edges that are heavily used in the local optimal tour and updating their distance in the edge distance matrix to prioritize less frequently used edges, thus promoting exploration of different routes, while scaling the update factor by the inverse square root of the edge's usage frequency.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    max_used_edge = np.max(edge_n_used)\n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n        updated_edge_distance[start][end] *= (1 + 1/np.sqrt(edge_n_used[start][end]+1))\n    return updated_edge_distance",
          "objective": 1.34281,
          "other_inf": null
     }
}