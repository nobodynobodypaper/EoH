{
     "parent1": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by incorporating the absolute difference between local and global optimum tours, the average edge usage, and a normal distribution of random numbers, and sorts the nodes based on a combination of the maximum distance from the global optimum tour and minimum edge usage to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    absolute_difference = np.abs(local_opt_tour - global_opt_tour)\n    average_edge_usage = np.mean(edge_n_used, axis=1)\n    randomness = np.random.normal(0, 1, size=(distance_matrix.shape[0], distance_matrix.shape[1]))\n    \n    new_distance_matrix = (0.5 * absolute_difference) + (0.4 * average_edge_usage) + (0.1 * randomness) + distance_matrix\n    \n    weighted_distance = 0.6 * np.max(new_distance_matrix, axis=1) + 0.4 * np.min(edge_n_used, axis=1)\n    perturb_nodes = np.argsort(weighted_distance)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10861,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by incorporating the absolute difference between local and global optimum tours, the average edge usage, and a normal distribution of random numbers, and sorts the nodes based on a combination of the maximum distance from the global optimum tour and minimum edge usage to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    absolute_difference = np.abs(local_opt_tour - global_opt_tour)\n    average_edge_usage = np.mean(edge_n_used, axis=1)\n    randomness = np.random.normal(0, 1, size=(distance_matrix.shape[0], distance_matrix.shape[1]))\n    \n    new_distance_matrix = (0.5 * absolute_difference) + (0.4 * average_edge_usage) + (0.1 * randomness) + distance_matrix\n    \n    weighted_distance = 0.6 * np.mean(new_distance_matrix, axis=1) + 0.4 * np.mean(edge_n_used, axis=1)\n    perturb_nodes = np.argsort(weighted_distance)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10185,
          "other_inf": null
     }
}