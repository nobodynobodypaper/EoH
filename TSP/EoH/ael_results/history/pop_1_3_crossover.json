{
     "parent1": {
          "algorithm": "The algorithm first updates the distance matrix based on the edge_n_used matrix, then calculates the difference between the two tours and sorts the nodes based on the difference to get the top nodes to perturb.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n    tour_difference = np.abs(local_opt_tour - global_opt_tour)\n    perturb_nodes = np.argsort(tour_difference)[::-1]\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.436,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "\nThe algorithm will first update the distance matrix based on the local_opt_tour and edge_n_used, then it will calculate the potential impact of perturbing each node on the current tour by comparing the distances of alternate paths to the global_opt_tour, and finally, it will sort the nodes based on the potential impact to find the top nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    # Calculate potential impact of perturbing each node\n    potential_impact = np.zeros(len(local_opt_tour))\n    for i in range(len(local_opt_tour)):\n        if i == len(local_opt_tour) - 1:\n            edge = (local_opt_tour[i], local_opt_tour[0])\n        else:\n            edge = (local_opt_tour[i], local_opt_tour[i+1])\n        potential_impact[i] = new_distance_matrix[local_opt_tour[i]][local_opt_tour[i-1]] - distance_matrix[global_opt_tour[i]][local_opt_tour[i-1]]\n    \n    # Sort nodes based on potential impact\n    perturb_nodes = np.argsort(potential_impact)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.245,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: \nThe algorithm will first calculate the impact of each edge (instead of node) on the current tour by comparing the distances of alternate paths to the global_opt_tour and then update the distance matrix based on the local_opt_tour and edge_n_used. Finally, it will sort the edges based on the potential impact to find the top ones to perturb. \n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Calculate potential impact of each edge on the tour\n    potential_impact = np.zeros(len(local_opt_tour))\n    for i in range(len(local_opt_tour)):\n        if i == len(local_opt_tour) - 1:\n            edge = (local_opt_tour[i], local_opt_tour[0])\n        else:\n            edge = (local_opt_tour[i], local_opt_tour[i+1])\n        potential_impact[i] = distance_matrix[edge[0]][edge[1]] - distance_matrix[global_opt_tour[i]][global_opt_tour[i-1]]\n    \n    # Sort edges based on potential impact\n    perturb_edges = np.argsort(potential_impact)[::-1]\n\n    # Update distance matrix\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n\n    # Identify the nodes corresponding to the top edges to perturb\n    perturb_nodes = np.unique(local_opt_tour[perturb_edges])\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.49,
          "first_obj": null
     }
}