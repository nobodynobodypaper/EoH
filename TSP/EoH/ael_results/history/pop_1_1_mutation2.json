{
     "parent2": {
          "algorithm": "\nThe algorithm first updates the distance matrix by modifying the distances of the edges included in the local optimum tour, then calculates the usage of each edge. Next, it sorts the nodes based on the difference between the distances of the edges in the local optimum tour and the global optimum tour, and returns the updated distance matrix and the sorted nodes as the perturb nodes.\n}\n\n```python\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n        new_distance_matrix[node1, node2] *= 1.1\n        new_distance_matrix[node2, node1] *= 1.1\n        edge_n_used[node1, node2] += 1\n        edge_n_used[node2, node1] += 1\n    perturb_nodes = np.argsort((global_opt_tour - local_opt_tour)[::-1])\n    return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n        new_distance_matrix[node1, node2] *= 1.1\n        new_distance_matrix[node2, node1] *= 1.1\n        edge_n_used[node1, node2] += 1\n        edge_n_used[node2, node1] += 1\n    perturb_nodes = np.argsort((global_opt_tour - local_opt_tour)[::-1])\n    return new_distance_matrix, perturb_nodes",
          "objective": 4.142,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: \nThe new algorithm first calculates the edge weights based on the difference between the local optimal tour and the global optimal tour. Then, it updates the distance matrix by modifying the distances of the edges included in the local optimum tour and sorts the nodes based on the edge weights to determine the top nodes to perturb. \n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    edge_weights = np.abs(local_opt_tour - global_opt_tour)\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n        new_distance_matrix[node1, node2] *= (1 + edge_weights[i])\n        new_distance_matrix[node2, node1] *= (1 + edge_weights[i])\n        edge_n_used[node1, node2] += 1\n        edge_n_used[node2, node1] += 1\n    perturb_nodes = np.argsort(edge_weights)[::-1]\n    return new_distance_matrix, perturb_nodes",
          "objective": 4.292,
          "first_obj": null
     }
}