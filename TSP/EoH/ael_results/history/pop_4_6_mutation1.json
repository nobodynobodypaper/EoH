{
     "parent1": {
          "algorithm": "\n\nAlgorithm description:\nThe algorithm first calculates the average distance traveled by each node in the local optimal tour, then updates the distance matrix based on the number of edges used in the local optimal tour. After that, it calculates the potential impact of each node to perturb the tour by considering both local and global optimal tours, and finally, sorts the nodes based on their impact to determine the top ones to perturb.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_dist_traveled = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour)-1):\n        avg_dist_traveled[local_opt_tour[i]] += np.sum(distance_matrix[local_opt_tour[i], local_opt_tour[i+1:]])/(len(local_opt_tour)-1-i)\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i] + avg_dist_traveled[i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.137,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description:\nThe algorithm first calculates the average distance between each node and the nodes in the local optimal tour. Then, it updates the distance matrix by considering the impact of perturbing each node based on the average distance. Next, it calculates the potential impact of each node to perturb the tour by considering both local and global optimal tours. Finally, it sorts the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_dist = np.zeros(distance_matrix.shape[0])\n    new_distance_matrix = np.copy(distance_matrix)\n\n    for i in range(len(local_opt_tour)-1):\n        for j in range(i+1, len(local_opt_tour)):\n            avg_dist[local_opt_tour[j]] += distance_matrix[local_opt_tour[i], local_opt_tour[j]]\n            avg_dist[local_opt_tour[i]] += distance_matrix[local_opt_tour[i], local_opt_tour[j]]\n    \n    avg_dist /= (len(local_opt_tour) - 1)\n    \n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0], edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1], edge[0]] += edge_n_used[edge]\n    \n    for i in range(len(global_opt_tour)-1):\n        edge = (global_opt_tour[i], global_opt_tour[i+1])\n        new_distance_matrix[edge[0], edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1], edge[0]] += edge_n_used[edge]\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i] + avg_dist[i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.297,
          "first_obj": null
     }
}