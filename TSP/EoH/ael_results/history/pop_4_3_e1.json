{
     "parent1": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix based on the local optimum tour, global optimum tour, and edge usage by implementing a unique scoring function, and then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different scoring function incorporating local optimum, global optimum, and edge usage\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) + (local_opt_tour - global_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)  # random perturbation\n\n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08595,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "Update the distance matrix by applying a nonlinear transformation to the edge usage and incorporating the difference between the local and global optimum tours, then sort the nodes based on the absolute difference between the maximum and minimum values in the updated distance matrix.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Apply a nonlinear transformation to the edge usage\n    transformed_edge_usage = np.power(edge_n_used, 1.5)\n    \n    # Incorporate the difference between local and global optimum tours\n    tour_difference = np.abs(global_opt_tour - local_opt_tour)\n    new_distance_matrix = distance_matrix + transformed_edge_usage - tour_difference\n    \n    # Sort the nodes based on the absolute difference between the maximum and minimum values in the updated distance matrix\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10194,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix based on a different unique scoring function incorporating local optimum, global optimum, and edge usage by applying the following formula: new_distance_matrix = distance_matrix + ((edge_n_used * 2) - (local_opt_tour - global_opt_tour)). Sort the nodes using a different scoring function for perturbation based on the difference between the maximum and minimum values in the updated distance matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different unique scoring function\n    new_distance_matrix = distance_matrix + ((edge_n_used * 2) - (local_opt_tour - global_opt_tour))\n    \n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.12805,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the element-wise maximum between the distance matrix and a randomized matrix, incorporates the difference between the local and global optimum tour by adding it to the distance matrix, and sorts the nodes based on the product of edge usage and the distance matrix to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by taking the element-wise maximum between the distance matrix and a randomized matrix\n    new_distance_matrix = np.maximum(distance_matrix, np.random.rand(*distance_matrix.shape))\n    \n    # Incorporate the difference between local and global optimum tours by adding it to the distance matrix\n    new_distance_matrix += local_opt_tour - global_opt_tour\n    \n    # Sort the nodes based on the product of edge usage and the distance matrix\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * edge_n_used, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10044,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a combination of the edge usage, local and global optimum tours, and sorts the nodes based on a unique scoring function to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a combination of edge usage and the difference between local and global optimum tours\n    new_distance_matrix = distance_matrix + (edge_n_used * 1.5) + (global_opt_tour - local_opt_tour)\n    \n    # Sort the nodes using a unique scoring function for perturbation\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * np.square(edge_n_used), axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10619,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by applying a logarithmic transformation to the edge usage and incorporating the ratio between the local and global optimum tours, then sort the nodes based on the sum of the squares of the difference between each value in the updated distance matrix and the average value in the matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Apply a logarithmic transformation to the edge usage\n    transformed_edge_usage = np.log(edge_n_used + 1)\n    \n    # Incorporate the ratio between local and global optimum tours\n    tour_ratio = local_opt_tour / global_opt_tour\n    \n    # Update the distance matrix\n    new_distance_matrix = distance_matrix + transformed_edge_usage * tour_ratio\n    \n    # Sort the nodes based on the sum of the squares of the difference between each value in the updated distance matrix and the average value in the matrix\n    average_value = np.mean(new_distance_matrix)\n    perturb_nodes = np.argsort(np.sum(np.square(new_distance_matrix - average_value), axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.15465,
          "other_inf": null
     }
}