{
     "parent1": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix based on the local optimum tour, global optimum tour, and edge usage by implementing a unique scoring function, and then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) + (local_opt_tour - global_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08343,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix using a unique scoring function that incorporates local optimum, global optimum, and edge usage, then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a unique scoring function\n    new_distance_matrix = distance_matrix + edge_n_used + (local_opt_tour - global_opt_tour) - np.random.uniform(0, 1, size=distance_matrix.shape)\n\n    # Sort the nodes using the maximum value in the updated distance matrix for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.0847,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "Create a new algorithm that updates the distance matrix by normalizing the edge usage and combining it with the average difference between local and global optimum tours, and sorts the nodes based on the minimum distance from the global optimum tour and maximum normalized edge usage to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Normalize edge usage\n    normalized_edge_usage = edge_n_used / np.max(edge_n_used)\n    \n    # Combine with the average difference between local and global optimum tours\n    combined_metric = (0.6 * normalized_edge_usage) + (0.4 * (local_opt_tour - global_opt_tour))\n    \n    # Update the distance matrix based on the combined metric\n    new_distance_matrix = distance_matrix + combined_metric\n    \n    # Sort the nodes based on the minimum distance from the global optimum tour and maximum normalized edge usage\n    perturb_nodes = np.argsort(np.maximum(np.min(new_distance_matrix, axis=1), np.max(normalized_edge_usage, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.06714,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix based on the local optimum tour, global optimum tour, and edge usage by implementing a unique scoring function, and then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) + (local_opt_tour - global_opt_tour) + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08343,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix using a unique scoring function that incorporates local optimum, global optimum, and edge usage, then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a unique scoring function\n    new_distance_matrix = distance_matrix + edge_n_used + (local_opt_tour - global_opt_tour) - np.random.uniform(0, 1, size=distance_matrix.shape)\n\n    # Sort the nodes using the maximum value in the updated distance matrix for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.0847,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix using a combination of local optimum tour, global optimum tour, and edge usage, and then sorts the nodes based on a unique scoring function to find the top ones to perturb for minimizing total distance.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + (edge_n_used * 3) - (local_opt_tour + global_opt_tour) + np.random.uniform(-1, 1, size=distance_matrix.shape)\n\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.23236,
          "other_inf": null
     }
}