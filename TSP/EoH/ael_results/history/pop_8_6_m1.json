{
     "parent1": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix by introducing a mutation factor that is dependent on the edge count, distance, and usage, aiming to encourage exploration while also considering the impact of individual edge usage.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_count = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] += (np.random.uniform(0.7, 1.3) / edge_count[i][j]) + (edge_distance[i][j] / np.mean(edge_distance)) - (0.3 / np.max(edge_n_used)) * edge_n_used[i][j] * (1 + edge_count[i][j])\n\n    return updated_edge_distance",
          "objective": 0.02336,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix by incrementally adjusting the distances based on the usage of individual edges, aiming to promote exploration without excessively penalizing frequently used edges.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_count = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] += (np.random.uniform(0.8, 1.2) / edge_count[i][j]) + (edge_distance[i][j] / np.mean(edge_distance)) - (0.2 / np.max(edge_n_used)) * edge_n_used[i][j] * (1 + edge_count[i][j])\n\n    return updated_edge_distance",
          "objective": 0.02438,
          "other_inf": null
     }
}