{
     "parent1": {
          "algorithm": "\nThe algorithm idea is to first identify the edges that have the highest difference in distance compared to the global optimal tour, and then update the distance matrix based on the number of edges used in the local optimal tour. After that, calculate the potential impact of each node to perturb the tour by considering both local and global optimal tours, and finally, sort the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    diff_from_global = np.abs(np.sum(distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]]) - np.sum(distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]]))\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.986,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe algorithm will calculate the impact of perturbing each node by comparing the decrease in total distance in the local optimum tour to the decrease in the global optimum tour while also considering the edge usage, and then sort the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix.copy()\n    \n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n    \n    decrease_local = np.sum(distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]]) - np.sum(new_distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]])\n    \n    decrease_global = np.sum(distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]]) - np.sum(new_distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]])\n    \n    impact = (decrease_global - decrease_local) / (distance_matrix.shape[0] - len(local_opt_tour))\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}