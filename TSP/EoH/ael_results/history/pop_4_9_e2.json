{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a combination of the edge usage, local and global optimum tours, and sorts the nodes based on a unique scoring function to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a combination of edge usage and the difference between local and global optimum tours\n    new_distance_matrix = distance_matrix + (edge_n_used * 1.5) + (global_opt_tour - local_opt_tour)\n    \n    # Sort the nodes using a unique scoring function for perturbation\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * np.square(edge_n_used), axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10619,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "Update the distance matrix by applying a nonlinear transformation to the edge usage and incorporating the difference between the local and global optimum tours, then sort the nodes based on the absolute difference between the maximum and minimum values in the updated distance matrix.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Apply a nonlinear transformation to the edge usage\n    transformed_edge_usage = np.power(edge_n_used, 1.5)\n    \n    # Incorporate the difference between local and global optimum tours\n    tour_difference = np.abs(global_opt_tour - local_opt_tour)\n    new_distance_matrix = distance_matrix + transformed_edge_usage - tour_difference\n    \n    # Sort the nodes based on the absolute difference between the maximum and minimum values in the updated distance matrix\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10194,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the element-wise minimum between the distance matrix and a randomized matrix, incorporates the difference between the local and global optimum tour by subtracting it from the distance matrix, and sorts the nodes based on the sum of edge usage and the distance matrix to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.minimum(distance_matrix, np.random.rand(*distance_matrix.shape))\n    \n    new_distance_matrix -= local_opt_tour - global_opt_tour\n    \n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10009,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the element-wise minimum between the distance matrix and a randomized matrix, incorporates the difference between the local and global optimum tour by subtracting it from the distance matrix, and sorts the nodes based on the sum of edge usage and the distance matrix to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.minimum(distance_matrix, np.random.rand(*distance_matrix.shape))\n    \n    new_distance_matrix -= local_opt_tour - global_opt_tour\n    \n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10009,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "Update the distance matrix by scaling the edge usage with a random factor, incorporate the difference between the local and global optimum tour by adding it to the distance matrix, and sort the nodes based on the product of edge usage and the total distance difference to find the top ones to perturb.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    factor = np.random.rand()  # Generate a random scaling factor\n    scaled_edge_usage = edge_n_used * factor\n    new_distance_matrix = distance_matrix + scaled_edge_usage - (local_opt_tour - global_opt_tour)\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * edge_n_used, axis=1))  # Sort the nodes based on the product of edge usage and total distance difference\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.11079,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix by applying a custom nonlinear transformation to the edge usage and incorporates the difference between the local and global optimum tours, then sorting the nodes based on a novel scoring function.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Apply a custom nonlinear transformation to the edge usage\n    transformed_edge_usage = np.power(edge_n_used, 2)\n    \n    # Incorporate the difference between local and global optimum tours\n    tour_difference = np.abs(global_opt_tour - local_opt_tour)\n    new_distance_matrix = distance_matrix + transformed_edge_usage - tour_difference\n    \n    # Sort the nodes based on a novel scoring function\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1) * np.max(transformed_edge_usage, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.11364,
          "other_inf": null
     }
}