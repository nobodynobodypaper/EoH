{
     "parent1": {
          "algorithm": "New algorithm: Update the edge distances in the edge distance matrix based on the frequency of each edge used in the local optimal tour and the edge distance to guide the search towards a better solution.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] += np.log(edge_count[i][j] + 1) / np.log(2) * (1 / edge_n_used[i][j])\n\n    return updated_edge_distance",
          "objective": 0.13508,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nImplement a new algorithm that updates the edge distances in the edge distance matrix based on the frequency of each edge used in the local optimal tour using a modified noise factor that depends on the logarithm of the edge count to guide the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                noise_factor = np.random.uniform(-0.5 / np.log(edge_count[i][j] + 1), 0.5 / np.log(edge_count[i][j] + 1))\n                updated_edge_distance[i][j] += noise_factor\n\n    return updated_edge_distance",
          "objective": 0.10386,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "New algorithm: Update the edge distances in the edge distance matrix based on the frequency of each edge used in the local optimal tour using a modified noise factor that depends on the edge count, but with a higher noise factor range and additive factor for more exploration.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                noise_factor = np.random.uniform(-1 / edge_count[i][j], 1 / edge_count[i][j]) + np.random.uniform(0, 0.1)\n                updated_edge_distance[i][j] += noise_factor\n\n    return updated_edge_distance",
          "objective": 0.14217,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the product of the frequency of each edge used in the local optimal tour and the reciprocal of the edge count to guide the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] += (edge_count[i][j] * (1 / max(edge_n_used[i][j], 1)))\n\n    return updated_edge_distance",
          "objective": 0.16233,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "The new algorithm uses a scaling factor that inversely depends on the square root of the edge count to update the edge distances in the edge distance matrix.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                scaling_factor = np.sqrt(edge_count[i][j])  # scaling factor based on edge count\n                noise_factor = np.random.uniform(-0.5 / scaling_factor, 0.5 / scaling_factor)\n                updated_edge_distance[i][j] += noise_factor\n\n    return updated_edge_distance",
          "objective": 0.10604,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the angle between edges in the local optimal tour and the edge distance to guide the search towards a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n\n    for i in range(len(local_opt_tour) - 2):\n        start = local_opt_tour[i]\n        middle = local_opt_tour[i+1]\n        end = local_opt_tour[i + 2]\n\n        vector1 = np.array([edge_distance[middle][start], edge_distance[middle][start]])\n        vector2 = np.array([edge_distance[middle][end], edge_distance[middle][end]])\n\n        angle = np.arccos(np.dot(vector1, vector2) / (np.linalg.norm(vector1) * np.linalg.norm(vector2)))\n\n        updated_edge_distance[middle][start] -= angle\n        updated_edge_distance[start][middle] -= angle\n\n        updated_edge_distance[middle][end] += angle\n        updated_edge_distance[end][middle] += angle\n\n    return updated_edge_distance",
          "objective": 3.49348,
          "other_inf": null
     }
}