{
     "parent1": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix by penalizing the distances between the nodes in the local optimal tour based on the number of times an edge is used in the global optimum tour, and then sort the nodes based on the penalty to identify the top nodes to perturb. The main steps include updating the distance matrix, calculating the penalty based on edge usage, sorting the nodes based on the penalty, and selecting the top nodes as perturb candidates.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    penalty_factor = 100  # Penalty factor for increasing penalty based on edge usage\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge_penalty = edge_n_used[local_opt_tour[i], local_opt_tour[i+1]] * penalty_factor\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_penalty\n    edge_penalty = edge_n_used[local_opt_tour[-1], local_opt_tour[0]] * penalty_factor\n    new_distance_matrix[local_opt_tour[-1], local_opt_tour[0]] += edge_penalty\n\n    perturb_penalty = np.sum(new_distance_matrix, axis=1)  # Calculate the penalty for each node\n    perturb_nodes = np.argsort(perturb_penalty)  # Sort the nodes based on the penalty\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.09,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "\nThe algorithm first updates the distance matrix based on the edges used in the local optimal tour, then calculates the difference between the local optimal tour and the global optimal tour to identify the nodes that cause the biggest difference. Finally, it sorts the nodes based on the differences and returns the updated distance matrix and the sorted nodes to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix * edge_n_used  # Update distance matrix based on edges used\n    difference = np.abs(local_opt_tour - global_opt_tour)  # Calculate the difference between local and global tours\n    perturb_nodes = np.argsort(difference)[::-1]  # Sort nodes based on difference in descending order\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.422,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix by incorporating the difference between the local optimal tour and the global optimal tour, and then sort the nodes based on this difference to identify the top nodes to perturb. The main steps include updating the distance matrix based on the tour differences, calculating the difference between the local and global tours, and finally sorting the nodes based on the difference to select the top nodes as perturb candidates.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + (global_opt_tour - local_opt_tour)  # Update distance matrix based on tour differences\n    tour_difference = np.abs(local_opt_tour - global_opt_tour)  # Calculate the difference between local and global tours\n    perturb_nodes = np.argsort(tour_difference)[::-1]  # Sort nodes based on difference in descending order\n    return new_distance_matrix, perturb_nodes",
          "objective": 4.292,
          "first_obj": null
     }
}