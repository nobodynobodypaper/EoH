{
     "parent1": {
          "algorithm": "The new algorithm aims to enhance the efficiency of calculating the impact of perturbing each node by avoiding redundant calculations. The main steps are to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb. The efficiency improvement will be achieved by only recalculating the impact values for the updated nodes rather than the entire matrix.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    impact = np.zeros(distance_matrix.shape[0])\n\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n        # Calculating impact for the updated nodes only\n        impact[local_opt_tour[i:i+2]] += np.sum(new_distance_matrix[local_opt_tour[i:i+2], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i:i+2]]) - np.sum(new_distance_matrix[local_opt_tour[i:i+2], local_opt_tour[i:i+2]])\n        impact[global_opt_tour[i:i+2]] += np.sum(new_distance_matrix[global_opt_tour[i:i+2], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i:i+2]]) - np.sum(new_distance_matrix[global_opt_tour[i:i+2], global_opt_tour[i:i+2]])\n\n    perturb_nodes = np.argsort(impact)\n        \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.066,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\n  The new algorithm aims to update the distance matrix by considering the impact of perturbing each node based on the local optimal tour, global optimal tour, and edge usage. Then, it will sort the nodes based on their impact while avoiding redundant calculations and unnecessary data structures.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    \n    # Updating the distance matrix and calculating the impact\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n        edge_usage = edge_n_used[node1, node2]\n\n        new_distance_matrix[node1, node2] += edge_usage\n        new_distance_matrix[node2, node1] += edge_usage\n\n        impact[node1] += np.sum(new_distance_matrix[node1, :]) + np.sum(new_distance_matrix[:, node1]) - new_distance_matrix[node1, node1]\n        impact[node2] += np.sum(new_distance_matrix[node2, :]) + np.sum(new_distance_matrix[:, node2]) - new_distance_matrix[node2, node2]\n    \n    for i in range(len(global_opt_tour) - 1):\n        node1 = global_opt_tour[i]\n        node2 = global_opt_tour[i + 1]\n        edge_usage = edge_n_used[node1, node2]\n\n        new_distance_matrix[node1, node2] += edge_usage\n        new_distance_matrix[node2, node1] += edge_usage\n        \n        impact[node1] += np.sum(new_distance_matrix[node1, :]) + np.sum(new_distance_matrix[:, node1]) - new_distance_matrix[node1, node1]\n        impact[node2] += np.sum(new_distance_matrix[node2, :]) + np.sum(new_distance_matrix[:, node2]) - new_distance_matrix[node2, node2]\n\n    # Sorting the nodes based on their impact in descending order\n    perturb_nodes = np.argsort(-impact)\n        \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.038,
          "first_obj": null
     }
}