{
     "parent2": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb to avoid being trapped in the local optimum tour while also considering the impact on the global tour.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.997,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: The algorithm idea is to calculate the impact of perturbing each node based on the local and global optimal tours and the edge usage, and then prioritize the nodes for perturbation based on their impact, taking into account both local and global tour optimization.\n\nCode:\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    impact = np.zeros(distance_matrix.shape[0])\n\n    # Calculate the impact of perturbing each node based on local and global optimal tours\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n\n        impact[local_opt_tour[i]] += np.sum(new_distance_matrix[local_opt_tour[i], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i]]) - new_distance_matrix[local_opt_tour[i], local_opt_tour[i]]\n        impact[local_opt_tour[i+1]] += np.sum(new_distance_matrix[local_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i+1]]) - new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i+1]\n\n        impact[global_opt_tour[i]] += np.sum(new_distance_matrix[global_opt_tour[i], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i]]) - new_distance_matrix[global_opt_tour[i], global_opt_tour[i]]\n        impact[global_opt_tour[i+1]] += np.sum(new_distance_matrix[global_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i+1]]) - new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i+1]\n\n    perturb_nodes = np.argsort(impact)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}