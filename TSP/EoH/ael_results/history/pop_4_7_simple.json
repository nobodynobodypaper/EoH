{
     "parent1": {
          "algorithm": "Update the distance matrix by applying a nonlinear transformation to the edge usage and incorporating the difference between the local and global optimum tours, then sort the nodes based on the absolute difference between the maximum and minimum values in the updated distance matrix.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Apply a nonlinear transformation to the edge usage\n    transformed_edge_usage = np.power(edge_n_used, 1.5)\n    \n    # Incorporate the difference between local and global optimum tours\n    tour_difference = np.abs(global_opt_tour - local_opt_tour)\n    new_distance_matrix = distance_matrix + transformed_edge_usage - tour_difference\n    \n    # Sort the nodes based on the absolute difference between the maximum and minimum values in the updated distance matrix\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10194,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Update the distance matrix by applying a nonlinear transformation to the edge usage and incorporating the difference between the local and global optimum tours, then sort the nodes based on the absolute difference between the maximum and minimum values in the updated distance matrix.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, edge_n_used):\n    # Apply a nonlinear transformation to the edge usage\n    transformed_edge_usage = np.power(edge_n_used, 1.5)\n    \n    new_distance_matrix = distance_matrix + transformed_edge_usage\n    \n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}