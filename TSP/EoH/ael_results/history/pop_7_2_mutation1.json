{
     "parent1": {
          "algorithm": "The algorithm idea is to first calculate the average distance of each node to the local optimal tour, then update the distance matrix by considering the impact of perturbing each node based on the average distance and the number of edges used in the local optimal tour. Finally, sort the nodes based on their impact to find the top ones to perturb.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_distance = np.mean(distance_matrix[:, local_opt_tour], axis=1)\n    \n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = avg_distance[i] + np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.988,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: The algorithm idea is to first calculate the impact of perturbing each node based on the number of edges used in the local optimal tour and the global optimal tour, and then update the distance matrix by considering this impact. Finally, sort the nodes based on their impact to find the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        impact[local_opt_tour[i]] += np.sum(distance_matrix[local_opt_tour[i], :]) + np.sum(distance_matrix[:, local_opt_tour[i]]) - distance_matrix[local_opt_tour[i], local_opt_tour[i]]\n        impact[local_opt_tour[i+1]] += np.sum(distance_matrix[local_opt_tour[i+1], :]) + np.sum(distance_matrix[:, local_opt_tour[i+1]]) - distance_matrix[local_opt_tour[i+1], local_opt_tour[i+1]\n        impact[global_opt_tour[i]] += np.sum(distance_matrix[global_opt_tour[i], :]) + np.sum(distance_matrix[:, global_opt_tour[i]]) - distance_matrix[global_opt_tour[i], global_opt_tour[i]]\n        impact[global_opt_tour[i+1]] += np.sum(distance_matrix[global_opt_tour[i+1], :]) + np.sum(distance_matrix[:, global_opt_tour[i+1]]) - distance_matrix[global_opt_tour[i+1], global_opt_tour[i+1]\n\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    perturb_nodes = np.argsort(impact)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}