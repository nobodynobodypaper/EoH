{
     "parent1": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix and select the top nodes to perturb in order to avoid getting stuck in a local optimum tour and achieve a tour with minimized total distance.\n}\n\n```python\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + edge_n_used * 50\n    perturb_nodes = np.argsort(global_opt_tour - local_opt_tour)\n    return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + edge_n_used * 50\n    perturb_nodes = np.argsort(global_opt_tour - local_opt_tour)\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.19434,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm to update the distance matrix and select the top nodes to perturb by adjusting the score function to prioritize nodes with the highest edge usage and minimize the overall total distance for the tour.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + edge_n_used * 100\n    perturb_nodes = np.argsort(edge_n_used)\n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}