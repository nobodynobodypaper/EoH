{
     "parent2": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix by penalizing the distances between the nodes in the local optimal tour based on the number of times an edge is used in the global optimum tour, and then sort the nodes based on the penalty to identify the top nodes to perturb. The main steps include updating the distance matrix, calculating the penalty based on edge usage, sorting the nodes based on the penalty, and selecting the top nodes as perturb candidates.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    penalty_factor = 100  # Penalty factor for increasing penalty based on edge usage\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge_penalty = edge_n_used[local_opt_tour[i], local_opt_tour[i+1]] * penalty_factor\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_penalty\n    edge_penalty = edge_n_used[local_opt_tour[-1], local_opt_tour[0]] * penalty_factor\n    new_distance_matrix[local_opt_tour[-1], local_opt_tour[0]] += edge_penalty\n\n    perturb_penalty = np.sum(new_distance_matrix, axis=1)  # Calculate the penalty for each node\n    perturb_nodes = np.argsort(perturb_penalty)  # Sort the nodes based on the penalty\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.09,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "The algorithm idea is to calculate the average distance between each node in the local optimal tour and its neighboring nodes, and then update the distance matrix by penalizing the distances based on the difference between the local and global optimal tours. Finally, sort the nodes based on the penalty to determine the top nodes to perturb.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_distances = np.zeros(distance_matrix.shape[0])\n    for i in range(1, len(local_opt_tour)-1):\n        avg_distances[local_opt_tour[i]] = (distance_matrix[local_opt_tour[i-1], local_opt_tour[i]] + distance_matrix[local_opt_tour[i], local_opt_tour[i+1]]) / 2\n    \n    penalty_factor = 100  # Penalty factor for increasing penalty based on distance difference\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        distance_penalty = abs(distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] - avg_distances[local_opt_tour[i]]) * penalty_factor\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += distance_penalty\n    distance_penalty = abs(distance_matrix[local_opt_tour[-1], local_opt_tour[0]] - avg_distances[local_opt_tour[-1]]) * penalty_factor\n    new_distance_matrix[local_opt_tour[-1], local_opt_tour[0]] += distance_penalty\n\n    perturb_penalty = np.sum(new_distance_matrix, axis=1)  # Calculate the penalty for each node\n    perturb_nodes = np.argsort(perturb_penalty)  # Sort the nodes based on the penalty\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 2.959,
          "first_obj": null
     }
}