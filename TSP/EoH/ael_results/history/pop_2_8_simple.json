{
     "parent1": {
          "algorithm": "\nNew algorithm: Calculate the difference in edge distances between the local optimal tour and the current edge distance matrix, and update the edge distances to penalize edges with larger differences and encourage edges with smaller differences, using a penalty factor proportional to the difference.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_diff = np.abs(updated_edge_distance - edge_distance)  # Calculate the difference in edge distances\n\n    penalty_factor = edge_diff / np.max(edge_diff)  # Calculate penalty factor proportional to the difference\n\n    updated_edge_distance += edge_diff * penalty_factor  # Update the edge distances to penalize and encourage edges\n    \n    return updated_edge_distance",
          "objective": 3.49348,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Calculate the difference in edge distances between the local optimal tour and the current edge distance matrix, and update the edge distances to penalize edges with larger differences and encourage edges with smaller differences, using a penalty factor proportional to the difference.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_diff = np.abs(updated_edge_distance - edge_distance)  # Calculate the difference in edge distances\n\n    penalty_factor = edge_diff / np.max(edge_diff)  # Calculate penalty factor proportional to the difference\n\n    updated_edge_distance += edge_diff * penalty_factor  # Update the edge distances to penalize and encourage edges\n    \n    return updated_edge_distance",
          "objective": 10000000000.0,
          "other_inf": null
     }
}