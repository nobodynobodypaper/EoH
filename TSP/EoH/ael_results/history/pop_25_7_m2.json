{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by multiplying the sum of the difference between the local and global optimum tours and the product of the average edge usage and a random factor by a weighted factor, then sorts the nodes based on the minimum distance from the global optimum tour and maximum edge usage to determine the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference = (local_opt_tour - global_opt_tour)\n    average_edge_usage = np.mean(edge_n_used, axis=1)\n    \n    weighted_factor = 0.5 # Example value, can be adjusted based on performance\n    \n    new_distance_matrix = distance_matrix + (tour_difference + average_edge_usage * np.random.rand(distance_matrix.shape[0])) * weighted_factor\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.04668,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix by using the absolute difference between the local and global optimum tours, the weighted average edge usage, and a random factor, then sorts the nodes based on the maximum distance from the global optimum tour and maximum edge usage to determine the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference = np.abs(local_opt_tour - global_opt_tour)\n    weighted_average_edge_usage = np.mean(edge_n_used, axis=1) * 0.7  # Example value, can be adjusted based on performance\n    weighted_factor = 0.6  # Example value, can be adjusted based on performance\n    \n    new_distance_matrix = distance_matrix + (tour_difference + weighted_average_edge_usage * np.random.rand(distance_matrix.shape[0])) * weighted_factor\n    max_distance = np.max(new_distance_matrix, axis=1)\n    max_edge_usage = np.max(edge_n_used, axis=1)\n    combined_score = max_distance + max_edge_usage\n    perturb_nodes = np.argsort(-combined_score)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.38152,
          "other_inf": null
     }
}