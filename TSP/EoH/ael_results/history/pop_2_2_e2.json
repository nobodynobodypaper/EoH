{
     "parent1": {
          "algorithm": "\n    The algorithm updates the distance matrix based on edge usage, then identifies and sorts the top nodes to perturb to prevent trapping in the local optimum tour. \n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix * edge_n_used\n    perturb_nodes = np.argsort(np.abs(local_opt_tour - global_opt_tour))[::-1]\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.20663,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\n    The algorithm updates the distance matrix based on edge usage, then identifies and sorts the top nodes to perturb to prevent trapping in the local optimum tour. \n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix * edge_n_used\n    perturb_nodes = np.argsort(np.abs(local_opt_tour - global_opt_tour))[::-1]\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.20663,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix based on a different unique scoring function incorporating local optimum, global optimum, and edge usage, and then sorts the nodes using a different scoring function for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different unique scoring function\n    new_distance_matrix = distance_matrix + ((edge_n_used * 3) / 2) + ((local_opt_tour - global_opt_tour) * 2)\n    \n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.14446,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nNew algorithm: Identify the nodes with the highest impact on the edge usage by considering both the local and global optimal tours, update the distance matrix based on the edge usage with a penalty for edges used in the local optimal tour, and sort the nodes based on the impact for perturbation to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Identify nodes with the highest impact on edge usage\n    impact_nodes = np.argmax(edge_n_used, axis=1)\n    \n    # Update distance matrix based on edge usage with penalty for edges used in local optimal tour\n    penalty = 1.1\n    new_distance_matrix = distance_matrix * (1 + edge_n_used) \n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort nodes based on impact for perturbation\n    perturb_nodes = np.argsort(impact_nodes)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.22023,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "Create a new algorithm to identify the nodes with the highest impact on the edge usage, update the distance matrix based on the edge usage, and sort the nodes based on the impact for perturbation to avoid local optimum and minimize total distance.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Identify nodes with the highest impact on edge usage\n    impact_nodes = np.argmax(edge_n_used, axis=1)\n    \n    # Update distance matrix based on edge usage\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n    \n    # Sort nodes based on impact for perturbation\n    perturb_nodes = np.argsort(impact_nodes)[::-1]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.17128,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix with penalties for edges used in the local optimum tour, incorporates a unique scoring function based on edge usage and tour comparisons, and then sorts the nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix with penalties for edges used in the local optimum tour\n    penalty = 1.2\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Incorporate a unique scoring function based on edge usage and tour comparisons\n    unique_scoring = edge_n_used**2 + np.abs(local_opt_tour - global_opt_tour)\n    \n    # Sort the nodes for perturbation based on the unique scoring function\n    perturb_nodes = np.argsort(np.sum(unique_scoring, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.2202,
          "other_inf": null
     }
}