{
     "parent1": {
          "algorithm": " ",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    normalization_factor = np.mean(edge_n_used, axis=1) / np.max(edge_n_used)\n    weighted_metric = (0.5 * edge_n_used) + (0.3 * (local_opt_tour - global_opt_tour)) + (0.2 * normalization_factor)\n    new_distance_matrix = distance_matrix + weighted_metric\n    \n    perturb_nodes = np.argsort(np.maximum(np.mean(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.20004,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm will update the distance matrix and sort the top nodes to perturb by using a different score function, which includes 0.4 * edge_n_used + 0.4 * (local_opt_tour - global_opt_tour) + 0.2 * normalization_factor.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    normalization_factor = np.mean(edge_n_used, axis=1) / np.max(edge_n_used)\n    weighted_metric = (0.4 * edge_n_used) + (0.4 * (local_opt_tour - global_opt_tour)) + (0.2 * normalization_factor)\n    new_distance_matrix = distance_matrix + weighted_metric\n    \n    perturb_nodes = np.argsort(np.maximum(np.mean(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.14456,
          "other_inf": null
     }
}