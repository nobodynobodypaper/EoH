{
     "parent1": {
          "algorithm": "Create an algorithm that updates the distance matrix by integrating the distance from the global optimum tour, edge usage, and a new factor, then sorts the nodes based on a combination of maximum edge usage and minimum distance from the global optimum tour to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Calculate the new factor based on a combination of local and global optimum tours\n    new_factor = local_opt_tour + global_opt_tour / (np.sqrt(edge_n_used) + 1)\n    \n    # Update the distance matrix using the new factor and existing components\n    new_distance_matrix = (0.4 * new_factor) + (0.3 * edge_n_used) + (0.3 * distance_matrix)\n    \n    # Sort the nodes based on maximum edge usage and minimum distance from the global optimum tour\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.19246,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Create an algorithm that updates the distance matrix by integrating the distance from the global optimum tour, edge usage, and a new factor, then sorts the nodes based on the minimum distance from the global optimum tour and maximum edge usage to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Calculate the new factor based on a combination of local and global optimum tours\n    new_factor = (local_opt_tour + global_opt_tour) / (np.sqrt(edge_n_used) + 1)\n    \n    # Update the distance matrix using the new factor and existing components\n    new_distance_matrix = (0.4 * new_factor) + (0.3 * edge_n_used) + (0.3 * distance_matrix)\n    \n    # Sort the nodes based on minimum distance from the global optimum tour and maximum edge usage\n    perturb_nodes = np.argsort(np.minimum(np.min(new_distance_matrix, axis=1), np.max(edge_n_used, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.13276,
          "other_inf": null
     }
}