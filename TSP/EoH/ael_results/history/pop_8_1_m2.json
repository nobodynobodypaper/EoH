{
     "parent1": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix using a unique scoring function that incorporates local optimum, global optimum, and edge usage, then sort the nodes based on a different scoring function to find the top ones to perturb to avoid local optimum and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a unique scoring function\n    new_distance_matrix = distance_matrix + edge_n_used + (local_opt_tour - global_opt_tour) - np.random.uniform(0, 1, size=distance_matrix.shape)\n\n    # Sort the nodes using the maximum value in the updated distance matrix for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.0847,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix using a scoring function that incorporates the difference between local optimum and global optimum tours, edge usage, and the inverse of the distance matrix, then sort the nodes based on a different scoring function to find the top ones to perturb and minimize total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix using a unique scoring function\n    new_distance_matrix = (1 / distance_matrix) + (local_opt_tour - global_opt_tour) + edge_n_used\n\n    # Sort the nodes using the sum of values in the updated distance matrix for perturbation\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.14426,
          "other_inf": null
     }
}