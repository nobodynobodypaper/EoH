{
     "parent2": {
          "algorithm": "\nThe algorithm first updates the distance matrix based on the information from the local optimal tour and global optimal tour, then it sorts the nodes based on their potential to perturb the tour to avoid local optimum, and finally returns the updated distance matrix and the sorted nodes.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = distance_matrix + np.outer(local_opt_tour, global_opt_tour)\n    \n    # Sort nodes based on potential perturbation effect\n    perturb_nodes = np.argsort(np.sum(edge_n_used, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.548,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb to avoid being trapped in the local optimum tour while also considering the impact on the global tour.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.997,
          "first_obj": null
     }
}