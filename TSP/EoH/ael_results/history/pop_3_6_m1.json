{
     "parent1": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are least frequently used and update their distances in the edge distance matrix to encourage using them more, thereby guiding the search towards a better solution by promoting unexplored edges.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.ones_like(edge_distance) * np.amax(edge_n_used)  # Initialize edge_count with maximum edge usage\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] = edge_n_used[start][end]  # Update edge_count with actual edge usage\n\n    updated_edge_distance /= (1 + edge_count / edge_n_used)\n\n    return updated_edge_distance",
          "objective": 0.24818,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: The strategy is to identify the edges in the local optimal tour that are the farthest away from each other and update their distances in the edge distance matrix to encourage exploring alternative routes and potentially finding a better solution.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        if edge_n_used[start][end] == 0:\n            updated_edge_distance[start][end] *= 1.1   # Increase distance for least used edges\n\n    return updated_edge_distance",
          "objective": 3.084,
          "other_inf": null
     }
}