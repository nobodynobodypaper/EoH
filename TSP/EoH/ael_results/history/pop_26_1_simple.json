{
     "parent1": {
          "algorithm": "Create a new algorithm that computes the weighted sum of the normalized edge usage, the difference between the local and global optimum tours, and a random factor, and then sorts the nodes based on the maximum edge usage and minimum distance from the global optimum tour to determine the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    weighted_combined_metric = (0.4 * (edge_n_used / np.max(edge_n_used))) + (0.6 * (local_opt_tour - global_opt_tour))\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = distance_matrix + weighted_combined_metric + (0.1 * randomness)\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.05258,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that computes the weighted sum of the normalized edge usage, the difference between the local and global optimum tours, and a random factor, and then sorts the nodes based on the maximum edge usage and minimum distance from the global optimum tour to determine the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    edge_n_used_max = np.max(edge_n_used)\n    local_global_diff = local_opt_tour - global_opt_tour\n    weighted_combined_metric = (0.4 * (edge_n_used / edge_n_used_max)) + (0.6 * local_global_diff)\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = distance_matrix + weighted_combined_metric + (0.1 * randomness)\n    max_edge_n_used = np.max(edge_n_used, axis=1)\n    min_new_distance = np.min(new_distance_matrix, axis=1)\n    max_edge_n_used_or_min_distance = np.maximum(max_edge_n_used, min_new_distance)\n    perturb_nodes = np.argsort(max_edge_n_used_or_min_distance)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.07789,
          "other_inf": null
     }
}