{
     "parent1": {
          "algorithm": "\nThe algorithm idea is to first identify the edges that have the highest difference in distance compared to the global optimal tour, and then update the distance matrix based on the number of edges used in the local optimal tour. After that, calculate the potential impact of each node to perturb the tour by considering both local and global optimal tours, and finally, sort the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    diff_from_global = np.abs(np.sum(distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]]) - np.sum(distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]]))\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.986,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "The algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours. However, instead of directly sorting the nodes based on their impact, we will first create a priority queue where the priority is based on the impact value. Then, we will dequeue the top nodes from the priority queue to get the nodes to perturb.",
          "code": "import numpy as np\nimport heapq\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = []\n    for node, imp in enumerate(impact):\n        heapq.heappush(perturb_nodes, (imp, node))\n    \n    perturb_nodes = [node for _, node in perturb_nodes]\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.937,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm idea is to first calculate the impact of perturbing each node based on the local and global optimal tours. Then, instead of directly sorting the nodes, we will divide the nodes into clusters based on their impact value, and finally select the top nodes to perturb from each cluster, ensuring a more diverse set of nodes to perturb.\n}\n\n```python\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix.copy()\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n        impact[local_opt_tour[i]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        impact[local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        \n        impact[global_opt_tour[i]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        impact[global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n    \n    clusters = {}\n    for node, imp in enumerate(impact):\n        if imp not in clusters:\n            clusters[imp] = []\n        clusters[imp].append(node)\n    \n    perturb_nodes = []\n    for imp, nodes in sorted(clusters.items(), reverse=True):\n        perturb_nodes.extend(nodes[:2])\n    \n    return new_distance_matrix, np.array(perturb_nodes)\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix.copy()\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n        impact[local_opt_tour[i]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        impact[local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        \n        impact[global_opt_tour[i]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        impact[global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n    \n    clusters = {}\n    for node, imp in enumerate(impact):\n        if imp not in clusters:\n            clusters[imp] = []\n        clusters[imp].append(node)\n    \n    perturb_nodes = []\n    for imp, nodes in sorted(clusters.items(), reverse=True):\n        perturb_nodes.extend(nodes[:2])\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}