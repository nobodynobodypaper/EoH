{
     "parent1": {
          "algorithm": "Updated based on the frequency of the edge used, non-linear transformation, normalized factor, and penalty for overused edges.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                transformation_factor = (edge_count[i][j] ** 2) / (edge_distance[i][j] + 1)  # Custom non-linear transformation\n                normalized_factor = (1 / max(edge_n_used[i][j], 1))\n                penalty = 0.5 if edge_n_used[i][j] > 1 else 0  # Penalty for overused edges\n                updated_edge_distance[i][j] += transformation_factor + normalized_factor - penalty\n\n    return updated_edge_distance",
          "objective": 0.0349,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm aims to update the edge distance matrix based on the frequency of the edge used, a linear transformation, a normalized factor, and penalty for overused edges, with different parameter settings of the score function.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                transformation_factor = (edge_count[i][j] ** 2) / (edge_distance[i][j] + 1)  # Custom linear transformation\n                normalized_factor = (1 / max(edge_n_used[i][j], 1))\n                penalty = 1 if edge_n_used[i][j] > 2 else 0  # Penalty for overused edges\n                updated_edge_distance[i][j] += transformation_factor + normalized_factor - penalty\n\n    return updated_edge_distance",
          "objective": 0.17873,
          "other_inf": null
     }
}