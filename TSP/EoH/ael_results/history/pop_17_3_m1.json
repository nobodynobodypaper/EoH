{
     "parent1": {
          "algorithm": "Create a new algorithm that updates the distance matrix by incorporating a weighted sum of the average edge usage, the difference between local and global optimum tours, and a combination of randomness, and then sorts the nodes based on a weighed combination of edge usage and the adjusted difference from the global optimum tour to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    average_edge_usage = np.mean(edge_n_used, axis=1)\n    adjusted_difference = ((local_opt_tour - global_opt_tour) / np.max(local_opt_tour - global_opt_tour))\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    \n    new_distance_matrix = (0.3 * average_edge_usage) + (0.4 * adjusted_difference) + (0.2 * randomness) + distance_matrix\n    \n    weighted_combination = 0.6 * np.max(edge_n_used, axis=1) + 0.4 * adjusted_difference\n    perturb_nodes = np.argsort(weighted_combination)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.49348,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the maximum edge usage, the squared difference between local and global optimum tours, and a combination of randomness, and then sorts the nodes based on a weighed combination of edge usage and the adjusted difference from the global optimum tour to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    max_edge_usage = np.max(edge_n_used, axis=1)\n    adjusted_difference = (local_opt_tour - global_opt_tour) ** 2\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    \n    new_distance_matrix = (0.2 * max_edge_usage) + (0.5 * adjusted_difference) + (0.3 * randomness) + distance_matrix\n    \n    weighted_combination = 0.7 * max_edge_usage + 0.3 * adjusted_difference\n    perturb_nodes = np.argsort(weighted_combination)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.19764,
          "other_inf": null
     }
}