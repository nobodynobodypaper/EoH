{
     "parent2": {
          "algorithm": "\nThe algorithm first identifies the nodes in the local optimal tour that have the highest difference in distance compared to the global optimal tour. It then updates the distance matrix based on the number of edges used in the local optimal tour and calculates the potential impact of each node to perturb the tour. Finally, it sorts the nodes based on their impact to determine the top nodes to perturb, and returns the updated distance matrix and the sorted nodes.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    diff_from_global = np.abs(np.sum(distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]]) - np.sum(distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]]))\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    perturb_potential = np.sum(edge_n_used * distance_matrix, axis=1)\n    perturb_nodes = np.argsort(perturb_potential)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.212,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "Algorithm description: \nThe algorithm idea is to first calculate the difference in distance between the local optimal tour and the global optimal tour. Then, it updates the distance matrix by considering the impact of perturbing each node based on the number of edges used in the local optimal tour and the difference in distance. Next, it calculates the potential impact of each node to perturb the tour, and finally sorts the nodes based on their impact to determine the top nodes to perturb, and returns the updated distance matrix and the sorted nodes.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    diff_from_global = np.abs(np.sum(distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]]) - np.sum(distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]]))\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n        \n    impact = np.sum(edge_n_used * new_distance_matrix, axis=1) * diff_from_global\n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.554,
          "first_obj": null
     }
}