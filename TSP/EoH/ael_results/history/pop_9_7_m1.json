{
     "parent1": {
          "algorithm": "Create a new algorithm that updates the distance matrix by taking the absolute difference between local and global optimum tours, subtracting edge usage, and sorts the nodes based on the maximum edge usage and the minimum distance from the global optimum tour to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    unique_score = np.abs(local_opt_tour - global_opt_tour)\n    new_distance_matrix = distance_matrix - edge_n_used - unique_score\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 3.49348,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the absolute difference between local and global optimum tours, subtracting a weighted sum of edge usage from the distance matrix, and sorts the nodes based on the maximum edge usage and the minimum distance from the global optimum tour to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    unique_score = np.abs(local_opt_tour - global_opt_tour)\n    weighted_edge_usage = np.sum(edge_n_used, axis=1) * 0.5  # Example weight of 0.5\n    new_distance_matrix = distance_matrix - weighted_edge_usage - unique_score\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.13649,
          "other_inf": null
     }
}