{
     "parent1": {
          "algorithm": "The new algorithm aims to enhance the efficiency of calculating the impact of perturbing each node by avoiding redundant calculations. The main steps are to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb. The efficiency improvement will be achieved by only recalculating the impact values for the updated nodes rather than the entire matrix.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    impact = np.zeros(distance_matrix.shape[0])\n\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n        # Calculating impact for the updated nodes only\n        impact[local_opt_tour[i:i+2]] += np.sum(new_distance_matrix[local_opt_tour[i:i+2], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i:i+2]]) - np.sum(new_distance_matrix[local_opt_tour[i:i+2], local_opt_tour[i:i+2]])\n        impact[global_opt_tour[i:i+2]] += np.sum(new_distance_matrix[global_opt_tour[i:i+2], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i:i+2]]) - np.sum(new_distance_matrix[global_opt_tour[i:i+2], global_opt_tour[i:i+2]])\n\n    perturb_nodes = np.argsort(impact)\n        \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.066,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nDescribe the algorithm idea and main steps:\nThe new algorithm identifies the nodes with the highest difference in impact compared to the local and global optimal tours and updates the distance matrix. Then, it calculates the potential impact of each node to perturb the tour and sorts the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    diff_impact = abs(np.sum(distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]]) - np.sum(distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]]))\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.986,
          "first_obj": null
     }
}