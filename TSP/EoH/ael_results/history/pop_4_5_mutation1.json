{
     "parent1": {
          "algorithm": "The algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb in order to avoid being trapped in the local optimum tour while also considering the impact on the global tour. The new algorithm will incorporate a more efficient method for calculating the impact of perturbing each node and prioritize the nodes for perturbation based on their combined impact on both the local and global optimal tours.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n\n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n\n        impact[local_opt_tour[i]] += np.sum(new_distance_matrix[local_opt_tour[i], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i]]) - new_distance_matrix[local_opt_tour[i], local_opt_tour[i]]\n        impact[local_opt_tour[i+1]] += np.sum(new_distance_matrix[local_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i+1]]) - new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i+1]]\n\n        impact[global_opt_tour[i]] += np.sum(new_distance_matrix[global_opt_tour[i], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i]]) - new_distance_matrix[global_opt_tour[i], global_opt_tour[i]]\n        impact[global_opt_tour[i+1]] += np.sum(new_distance_matrix[global_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i+1]]) - new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i+1]]\n\n    perturb_nodes = np.argsort(impact)\n        \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.022,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "Algorithm idea: \n\nThe algorithm idea is to calculate a perturbation score for each node by considering both the local and global optimal tours, and then sort the nodes based on their perturbation scores to identify the top nodes to perturb. The perturbation score is calculated by taking into account the impact of perturbing each node on the local and global optimal tours, as well as the penalty for using edges in the global optimal tour. The main steps include updating the distance matrix, calculating the perturbation score for each node, sorting the nodes based on the score, and selecting the top nodes to perturb.\n\nCode:",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n\n    perturb_score = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n\n        perturb_score[local_opt_tour[i]] += np.sum(new_distance_matrix[local_opt_tour[i], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i]]) - new_distance_matrix[local_opt_tour[i], local_opt_tour[i]]\n        perturb_score[local_opt_tour[i+1]] += np.sum(new_distance_matrix[local_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i+1]]) - new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i+1]]\n\n        perturb_score[global_opt_tour[i]] += np.sum(new_distance_matrix[global_opt_tour[i], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i]]) - new_distance_matrix[global_opt_tour[i], global_opt_tour[i]]\n        perturb_score[global_opt_tour[i+1]] += np.sum(new_distance_matrix[global_opt_tour[i+1], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i+1]]) - new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i+1]]\n\n    perturb_nodes = np.argsort(perturb_score)\n        \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.022,
          "first_obj": null
     }
}