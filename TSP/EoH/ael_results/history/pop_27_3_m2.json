{
     "parent1": {
          "algorithm": "new_distance_matrix, perturb_nodes",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference = (local_opt_tour - global_opt_tour) ** 2\n    average_edge_usage = np.mean(edge_n_used, axis=1)\n    weighted_factor = 0.5 \n    inverse_distance_matrix = 1 / (distance_matrix + 1)\n    \n    new_distance_matrix = distance_matrix + (tour_difference + average_edge_usage * np.random.rand(distance_matrix.shape[0]) + inverse_distance_matrix) * weighted_factor\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.max(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.04594,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nnew algorithm: The new algorithm aims to update the distance matrix and sort the top nodes to perturb by considering the squared difference between the local and global optimal tours, the average edge usage, and the inverse of the distance matrix weighted by a factor of 0.7 to avoid being trapped in a local optimum tour, with the final goal of finding a tour with minimized total distance.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference = (local_opt_tour - global_opt_tour) ** 2\n    average_edge_usage = np.mean(edge_n_used, axis=0)\n    weighted_factor = 0.7\n    inverse_distance_matrix = 1 / (distance_matrix + 1)\n    \n    new_distance_matrix = distance_matrix + (tour_difference + average_edge_usage * np.random.rand(distance_matrix.shape[0]) + inverse_distance_matrix) * weighted_factor\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.max(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.07046,
          "other_inf": null
     }
}