{
     "parent1": {
          "algorithm": "\nIdea: The algorithm will first update the distance matrix based on the local optimal tour, global optimal tour, and the number of times each edge is used. Then, it will sort the nodes based on a weighted combination of the distance to the closest neighbor and the number of times each node is visited in the tour to provide the top nodes to perturb to avoid being trapped in the local optimum tour.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update distance matrix\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n    \n    # Calculate weighted combination of distance to closest neighbor and number of times each node is visited in the tour\n    weighted_distance = np.min(new_distance_matrix, axis=1)\n    node_visits = np.bincount(local_opt_tour, minlength=len(distance_matrix))\n    weighted_combination = weighted_distance + (0.1 * node_visits)\n    \n    # Sort nodes based on the weighted combination\n    perturb_nodes = np.argsort(weighted_combination)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.377,
          "first_obj": null
     },
     "parent2": {
          "algorithm": "\n\nAlgorithm description: \nThe new algorithm idea is to create a new distance matrix based on the local optimal tour, global optimal tour, and number of times each edge is used. Then, it will identify the most critical nodes to perturb based on the edges with the highest usage in the updated distance matrix. In contrast to the previous algorithms, this approach aims to prioritize perturbation based on the impact of edge usage on the distance matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Create new distance matrix based on local optimal tour, global optimal tour, and edge usage\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n\n    # Identify perturb nodes based on edges with highest usage in updated distance matrix\n    perturb_nodes = np.argsort(-edge_n_used.sum(axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.326,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: \nIdea: The new algorithm will first calculate the impact of edge usage on the distance matrix and identify the most critical nodes to perturb based on this analysis, prioritizing nodes with the highest impact on the overall distance.\n\nCode:\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Calculate the impact of edge usage on the distance matrix\n    edge_impact = distance_matrix * edge_n_used\n    \n    # Identify perturb nodes based on the impact of edge usage on the distance matrix\n    perturb_nodes = np.argsort(-edge_impact.sum(axis=1))\n    \n    # Update distance matrix based on the local and global optimal tour\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.51,
          "first_obj": null
     }
}