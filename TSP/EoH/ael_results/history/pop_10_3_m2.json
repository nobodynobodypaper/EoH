{
     "parent1": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by incorporating a weighted average of the distance from the global optimum tour, edge usage, and a random factor, and sorts the nodes based on the minimum distance from the global optimum tour and maximum edge usage to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a weighted average of the distance from the global optimum tour, edge usage, and a random factor\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = (0.4 * np.min(distance_matrix, axis=1) + 0.4 * edge_n_used + 0.2 * randomness) + distance_matrix\n    \n    # Sort the nodes based on the minimum distance from the global optimum tour and maximum edge usage\n    perturb_nodes = np.argsort(np.maximum(np.min(new_distance_matrix, axis=1), np.max(edge_n_used, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.11777,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by incorporating a weighted average of the distance from the global optimum tour, edge usage, and the difference between the local and global optimum tour, and sorts the nodes based on the minimum of the updated distance matrix and the distance between local and global optimum tour to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a weighted average of the distance from the global optimum tour, edge usage, and the difference between the local and global optimum tour\n    difference_tours = np.abs(global_opt_tour - local_opt_tour)\n    new_distance_matrix = (0.3 * np.min(distance_matrix, axis=1) + 0.3 * edge_n_used + 0.4 * difference_tours) + distance_matrix\n    \n    # Sort the nodes based on the minimum of the updated distance matrix and the distance between local and global optimum tour\n    perturb_nodes = np.argsort(np.minimum(np.min(new_distance_matrix, axis=1), difference_tours))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.2238,
          "other_inf": null
     }
}