{
     "parent1": {
          "algorithm": "\nNew algorithm description: Create a new algorithm that updates the distance matrix by incorporating a random perturbation, scaling the edge usage, penalizing edges used in the local optimal tour, and sorting the nodes based on the product of edge usage and the total distance difference to find the top ones to perturb using a different penalty factor.\n\nCode:\n\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour with a different penalty factor\n    penalty = 1.2\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage, axis=1))\n\n    return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a random perturbation\n    new_distance_matrix = distance_matrix + np.random.uniform(-0.5, 0.5, size=distance_matrix.shape)\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour with a different penalty factor\n    penalty = 1.2\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.10751,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm description: Create a new algorithm that updates the distance matrix by introducing a simulated annealing perturbation, scaling the edge usage, penalizing edges used in the local optimal tour with a different penalty factor, and sorting the nodes based on the product of edge usage and the total distance difference to find the top ones to perturb using a different penalty factor.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by introducing a simulated annealing perturbation\n    simulated_annealing_perturbation = np.random.uniform(0.9, 1.1, size=distance_matrix.shape)\n    new_distance_matrix = distance_matrix * simulated_annealing_perturbation\n    \n    # Scale the edge usage\n    scaled_edge_usage = edge_n_used * np.random.rand()\n\n    # Penalize edges used in the local optimal tour with a different penalty factor\n    penalty = 1.3\n    for i in range(len(local_opt_tour)-1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] *= penalty\n    \n    # Sort the nodes based on the product of edge usage and the total distance difference\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix * scaled_edge_usage, axis=1))\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.30216,
          "other_inf": null
     }
}