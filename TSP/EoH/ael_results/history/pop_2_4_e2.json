{
     "parent1": {
          "algorithm": "\n\nThe algorithm first updates the distance matrix based on the edge usage and then calculates the difference between the local optimum tour and the global optimum tour. It then sorts the nodes based on the total distance difference to find the top ones to perturb.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + (edge_n_used * 2)  # Update the distance matrix based on edge usage with a factor of 2\n    perturb_nodes = np.argsort(np.abs(local_opt_tour - global_opt_tour))[::-1]  # Sort the nodes based on the total distance difference to find the top ones to perturb\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.20458,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix based on a different unique scoring function incorporating local optimum, global optimum, and edge usage, and then sorts the nodes using a different scoring function for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different unique scoring function\n    new_distance_matrix = distance_matrix + ((edge_n_used * 3) / 2) + ((local_opt_tour - global_opt_tour) * 2)\n    \n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.14446,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nCreate a new algorithm to update the distance matrix and select the top nodes to perturb in order to avoid getting stuck in a local optimum tour and achieve a tour with minimized total distance.\n}\n\n```python\nimport numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + edge_n_used * 50\n    perturb_nodes = np.argsort(global_opt_tour - local_opt_tour)\n    return new_distance_matrix, perturb_nodes\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + edge_n_used * 50\n    perturb_nodes = np.argsort(global_opt_tour - local_opt_tour)\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.19434,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix based on a different unique scoring function incorporating local optimum, global optimum, and edge usage by applying the following formula: new_distance_matrix = distance_matrix + ((edge_n_used * 2) - (local_opt_tour - global_opt_tour)). Sort the nodes using a different scoring function for perturbation based on the difference between the maximum and minimum values in the updated distance matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different unique scoring function\n    new_distance_matrix = distance_matrix + ((edge_n_used * 2) - (local_opt_tour - global_opt_tour))\n    \n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.12805,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix based on a different unique scoring function incorporating local optimum, global optimum, and edge usage by applying the following formula: new_distance_matrix = distance_matrix + ((edge_n_used * 2) - (local_opt_tour - global_opt_tour)). Sort the nodes using a different scoring function for perturbation based on the difference between the maximum and minimum values in the updated distance matrix.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix based on a different unique scoring function\n    new_distance_matrix = distance_matrix + ((edge_n_used * 2) - (local_opt_tour - global_opt_tour))\n    \n    # Sort the nodes using a different scoring function for perturbation\n    perturb_nodes = np.argsort(np.max(new_distance_matrix, axis=1) - np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.12805,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "Create a new algorithm that updates the distance matrix based on a combination of edge usage and differences between local and global optimum tour, and then sorts the nodes using a unique scoring function for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = distance_matrix + (edge_n_used * 2) - np.abs(local_opt_tour - global_opt_tour)\n    perturb_nodes = np.argsort(np.sum(new_distance_matrix, axis=1))  # Sort the nodes using a unique scoring function for perturbation\n    return new_distance_matrix, perturb_nodes",
          "objective": 0.14681,
          "other_inf": null
     }
}