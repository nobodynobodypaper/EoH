{
     "parent1": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, with the noise factor being a random value between -0.5 and 0.5, to escape from the local optimum and move towards a global optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        updated_edge_distance[start_node][end_node] += np.random.uniform(-0.5, 0.5)\n    \n    return updated_edge_distance",
          "objective": 0.24126,
          "other_inf": null
     },
     "parent2": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, with the noise factor being a random value between -0.5 and 0.5, to escape from the local optimum and move towards a global optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        updated_edge_distance[start_node][end_node] += np.random.uniform(-0.5, 0.5)\n    \n    return updated_edge_distance",
          "objective": 0.24126,
          "other_inf": null
     },
     "parent3": {
          "algorithm": "\nNew algorithm: Perturb the edge distances along the local optimal route by adding a random noise factor to each edge distance, with the noise factor being a random value between -0.5 and 0.5, to escape from the local optimum and move towards a global optimum.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour) - 1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i + 1]\n        edge_index = edge_n_used[start_node][end_node]\n        updated_edge_distance[start_node][end_node] += np.random.uniform(-0.5, 0.5)\n    \n    return updated_edge_distance",
          "objective": 0.24126,
          "other_inf": null
     },
     "parent4": {
          "algorithm": "Update the edge distances in the edge distance matrix based on frequency of each edge used in the local optimal tour using a modified noise factor that depends on the edge count to guide the search towards a better solution",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                noise_factor = np.random.uniform(-0.5 / edge_count[i][j], 0.5 / edge_count[i][j])\n                updated_edge_distance[i][j] += noise_factor\n\n    return updated_edge_distance",
          "objective": 0.09253,
          "other_inf": null
     },
     "parent5": {
          "algorithm": "New algorithm: Update the edge distances in the edge distance matrix based on the frequency of each edge used in the local optimal tour and the edge distance to guide the search towards a better solution.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] > 0:\n                updated_edge_distance[i][j] += np.log(edge_count[i][j] + 1) / np.log(2) * (1 / edge_n_used[i][j])\n\n    return updated_edge_distance",
          "objective": 0.13508,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the proximity of each edge to the starting and ending nodes of the local optimal tour to guide the search towards a better solution by prioritizing edges closer to the starting and ending nodes.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    start_node = local_opt_tour[0]\n    end_node = local_opt_tour[-1]\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if i == start_node or j == start_node or i == end_node or j == end_node:\n                updated_edge_distance[i][j] = edge_distance[i][j] * 0.85\n\n    return updated_edge_distance",
          "objective": 3.45938,
          "other_inf": null
     }
}