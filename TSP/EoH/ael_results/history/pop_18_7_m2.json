{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating the difference between the local and global optimum tours, edge usage, and a combination of random factors, and then sorts the nodes based on a weighted sum of edge usage and the minimum distance from the global optimum tour to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating the difference between the local and global optimum tours, edge usage, and a combination of random factors\n    random_factors = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    update_factor = (0.4 * (local_opt_tour - global_opt_tour)) + (0.5 * edge_n_used) + (0.1 * random_factors)\n    new_distance_matrix = update_factor + distance_matrix\n    \n    # Sort the nodes based on a weighted sum of edge usage and the minimum distance from the global optimum tour\n    weighted_perturb_nodes = 0.6 * np.max(edge_n_used, axis=1) + 0.4 * np.min(new_distance_matrix, axis=1)\n    perturb_nodes = np.argsort(weighted_perturb_nodes)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.09556,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by incorporating a combination of local and global tour differences, edge usage, and a new scoring function that includes the maximum distance from the global optimum tour and a random factor, then sorts the nodes based on this new scoring function to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating the difference between the local and global optimum tours, edge usage, and a combination of new scoring factors\n    random_factors = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    max_global_diff = np.max(global_opt_tour - local_opt_tour)\n    new_scoring_factor = (0.3 * max_global_diff) + (0.6 * edge_n_used) + (0.1 * random_factors)\n    new_distance_matrix = new_scoring_factor + distance_matrix\n    \n    # Sort the nodes based on the new scoring function\n    new_scoring_nodes = 0.7 * np.max(edge_n_used, axis=1) + 0.3 * np.min(new_distance_matrix, axis=1)\n    perturb_nodes = np.argsort(new_scoring_nodes)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.13184,
          "other_inf": null
     }
}