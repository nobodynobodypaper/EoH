{
     "parent1": {
          "algorithm": "\nAlgorithm description: The algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb. The new algorithm will incorporate a more efficient method for calculating the impact of perturbing each node and prioritize the nodes for perturbation based on their combined impact on both the local and global optimal tours.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n\n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]\n                                                                      ]\n\n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n\n        impact[local_opt_tour[i:i+2]] += np.sum(new_distance_matrix[local_opt_tour[i:i+2], :]) + np.sum(new_distance_matrix[:, local_opt_tour[i:i+2]], axis=0) - new_distance_matrix[local_opt_tour[i:i+2], local_opt_tour[i:i+2]]\n\n        impact[global_opt_tour[i:i+2]] += np.sum(new_distance_matrix[global_opt_tour[i:i+2], :]) + np.sum(new_distance_matrix[:, global_opt_tour[i:i+2]], axis=0) - new_distance_matrix[global_opt_tour[i:i+2], global_opt_tour[i:i+2]]\n\n    perturb_nodes = np.argsort(impact)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.035,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: The algorithm idea is to use a greedy approach to update the distance matrix by iteratively perturbing the nodes based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb. The main steps include updating the distance matrix, calculating the impact of perturbing each node, and sorting the nodes based on their impact.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n\n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n\n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n\n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour) - 1):\n        current_node = local_opt_tour[i]\n        next_node = local_opt_tour[i+1]\n        impact[current_node] += new_distance_matrix[current_node, next_node] + new_distance_matrix[next_node, current_node] - distance_matrix[current_node, next_node] - distance_matrix[next_node, current_node]\n\n    for i in range(len(global_opt_tour) - 1):\n        current_node = global_opt_tour[i]\n        next_node = global_opt_tour[i+1]\n        impact[current_node] += new_distance_matrix[current_node, next_node] + new_distance_matrix[next_node, current_node] - distance_matrix[current_node, next_node] - distance_matrix[next_node, current_node]\n\n    perturb_nodes = np.argsort(-impact)\n\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.602,
          "first_obj": null
     }
}