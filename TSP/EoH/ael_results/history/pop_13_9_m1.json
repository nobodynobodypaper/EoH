{
     "parent1": {
          "algorithm": "Create an algorithm that updates the distance matrix by incorporating a weighted average of the difference between local and global optimum tours, edge usage, and randomness, and sorts the nodes based on a combination of minimum distance from the global optimum tour and maximum edge usage to identify the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a weighted average of the difference between local and global optimum tours, edge usage, and randomness\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = (0.6 * (local_opt_tour - global_opt_tour)) + (0.3 * edge_n_used) + (0.1 * randomness) + distance_matrix\n    \n    # Sort the nodes based on a combination of maximum distance from the global optimum tour and minimum edge usage\n    min_distance = np.min(new_distance_matrix, axis=1)\n    max_edge_usage = np.max(edge_n_used, axis=1)\n    weighted_distance = 0.4 * min_distance + 0.6 * max_edge_usage\n    perturb_nodes = np.argsort(weighted_distance)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.06676,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm description: Create an algorithm that updates the distance matrix by incorporating the difference between local and global optimum tours, edge usage, and randomness, and sorts the nodes based on a combination of minimum distance from the global optimum tour and maximum edge usage to identify the top nodes for perturbation, using a different set of weights and a different sorting method.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    # Update the distance matrix by incorporating a different weighted average of the difference between local and global optimum tours, edge usage, and randomness\n    randomness = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    new_distance_matrix = (0.5 * (local_opt_tour - global_opt_tour)) + (0.4 * edge_n_used) + (0.1 * randomness) + distance_matrix\n    \n    # Sort the nodes based on a combination of minimum distance from the global optimum tour and maximum edge usage\n    max_distance = np.max(new_distance_matrix, axis=1)\n    min_edge_usage = np.min(edge_n_used, axis=1)\n    weighted_distance = 0.3 * max_distance + 0.7 * min_edge_usage\n    perturb_nodes = np.argsort(weighted_distance)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.08184,
          "other_inf": null
     }
}