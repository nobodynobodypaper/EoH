{
     "parent1": {
          "algorithm": "The algorithm idea is to calculate the impact of perturbing each node based on the average distance, the number of edges used in the local optimal tour, and the number of nodes that can be accessed from each node. Then, update the distance matrix by considering this impact and sort the nodes based on their impact to find the top ones to perturb.",
          "code": "import numpy as np\n  \ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_distance = np.mean(distance_matrix[:, local_opt_tour], axis=1)\n    access_count = np.sum(np.where(edge_n_used > 0, 1, 0), axis=1)\n    \n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = avg_distance[i] + np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - (2 * access_count[i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.058,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nAlgorithm description: The algorithm aims to identify nodes that are in close proximity to each other and have high traffic flow, thus making them ideal candidates for perturbation in order to escape local optima. The main steps involve identifying nodes with high edge usage, calculating their average distance to neighboring nodes, updating the distance matrix to reflect the impact of perturbing these nodes, and then sorting the nodes based on this impact to find the top ones to perturb.\n\n",
          "code": "import numpy as np\n  \ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_distance = np.mean(distance_matrix[:, local_opt_tour], axis=1)\n    edge_usage = np.sum(edge_n_used, axis=1)\n    \n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = avg_distance * edge_usage\n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.238,
          "first_obj": null
     }
}