{
     "parent1": {
          "algorithm": "\nThe new algorithm will update the edge distance matrix by identifying and prioritizing the least used edges in the local optimal tour, decreasing their distances to encourage further exploration of those paths, while increasing the distances of heavily used edges to discourage revisiting them.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if edge_count[i][j] == 0:\n                updated_edge_distance[i][j] *= 0.9  # Decrease distance of least used edges\n            else:\n                updated_edge_distance[i][j] *= 1.1  # Increase distance of heavily used edges\n\n    return updated_edge_distance",
          "objective": 2.82733,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nThe new algorithm will update the edge distance matrix by identifying and prioritizing the least used edges in the local optimal tour, decreasing their distances to encourage further exploration of those paths, while increasing the distances of heavily used edges to discourage revisiting them.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    edge_count = np.zeros_like(edge_distance)\n    for i in range(len(local_opt_tour) - 1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i + 1]\n        edge_count[start][end] += 1\n        edge_count[end][start] += 1\n    \n    for i in range(updated_edge_distance.shape[0]):\n        for j in range(updated_edge_distance.shape[1]):\n            if edge_count[i][j] >= 0.9 * edge_n_used[i][j]:  # Decrease distance of least used edges\n                updated_edge_distance[i][j] *= 0.9  \n            elif edge_count[i][j] <= 1.1 * edge_n_used[i][j]:  # Increase distance of heavily used edges\n                updated_edge_distance[i][j] *= 1.1\n\n    return updated_edge_distance",
          "objective": 3.49348,
          "other_inf": null
     }
}