{
     "parent1": {
          "algorithm": "\nThe algorithm idea is to update the distance matrix by considering the impact of perturbing each node based on both the local and global optimal tours, and then sort the nodes based on their impact to find the top ones to perturb to avoid being trapped in the local optimum tour while also considering the impact on the global tour.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    new_distance_matrix = np.copy(distance_matrix)\n    \n    for i in range(len(local_opt_tour) - 1):\n        new_distance_matrix[local_opt_tour[i], local_opt_tour[i+1]] += edge_n_used[local_opt_tour[i], local_opt_tour[i+1]]\n        new_distance_matrix[local_opt_tour[i+1], local_opt_tour[i]] += edge_n_used[local_opt_tour[i+1], local_opt_tour[i]]\n        \n        new_distance_matrix[global_opt_tour[i], global_opt_tour[i+1]] += edge_n_used[global_opt_tour[i], global_opt_tour[i+1]]\n        new_distance_matrix[global_opt_tour[i+1], global_opt_tour[i]] += edge_n_used[global_opt_tour[i+1], global_opt_tour[i]]\n        \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.997,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe algorithm idea is to first calculate the impact of each edge on the local optimal tour by considering the change in distance compared to the global optimal tour. Then, based on the number of edges used in the local optimal tour, update the distance matrix and finally, sort the nodes based on their potential impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    impact = np.abs(np.sum(distance_matrix[local_opt_tour[:-1], local_opt_tour[1:]]) - np.sum(distance_matrix[global_opt_tour[:-1], global_opt_tour[1:]]))\n\n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "first_obj": null
     }
}