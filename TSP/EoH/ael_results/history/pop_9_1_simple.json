{
     "parent1": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by taking the difference between local and global optimum tours and edge usage, and then sorts the nodes based on the maximum difference and edge usage to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    unique_score = (local_opt_tour - global_opt_tour)\n    \n    new_distance_matrix = distance_matrix + unique_score + edge_n_used\n    \n    perturb_nodes = np.argsort(np.maximum(unique_score, np.max(edge_n_used, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.07293,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate an algorithm that updates the distance matrix by taking the difference between local and global optimum tours and edge usage, and then sorts the nodes based on the maximum difference and edge usage to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, unique_score, edge_n_used):\n    new_distance_matrix = distance_matrix + unique_score + edge_n_used\n    \n    perturb_nodes = np.argsort(np.maximum(unique_score, np.max(edge_n_used, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 10000000000.0,
          "other_inf": null
     }
}