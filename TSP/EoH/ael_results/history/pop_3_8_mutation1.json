{
     "parent1": {
          "algorithm": "\n\nAlgorithm description:\nThe algorithm first calculates the average distance traveled by each node in the local optimal tour, then updates the distance matrix based on the number of edges used in the local optimal tour. After that, it calculates the potential impact of each node to perturb the tour by considering both local and global optimal tours, and finally, sorts the nodes based on their impact to determine the top ones to perturb.\n\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    avg_dist_traveled = np.zeros(distance_matrix.shape[0])\n    for i in range(len(local_opt_tour)-1):\n        avg_dist_traveled[local_opt_tour[i]] += np.sum(distance_matrix[local_opt_tour[i], local_opt_tour[i+1:]])/(len(local_opt_tour)-1-i)\n    \n    new_distance_matrix = distance_matrix.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        new_distance_matrix[edge[0]][edge[1]] += edge_n_used[edge]\n        new_distance_matrix[edge[1]][edge[0]] += edge_n_used[edge]\n    \n    impact = np.zeros(distance_matrix.shape[0])\n    for i in range(len(impact)):\n        impact[i] = np.sum(new_distance_matrix[i, :]) + np.sum(new_distance_matrix[:, i]) - new_distance_matrix[i, i] + avg_dist_traveled[i]\n    \n    perturb_nodes = np.argsort(impact)\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 1.137,
          "first_obj": null
     },
     "offspring": {
          "algorithm": "\nThe algorithm first calculates the overall difference between the local optimal tour and the global optimal tour, then updates the distance matrix based on the edges used in the local optimal tour and the number of times each edge is used. After that, it identifies the nodes that contribute the most to the difference in tours by considering the impact of each node, and finally, sorts the nodes based on their impact to determine the top ones to perturb.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    overall_difference = np.abs(local_opt_tour - global_opt_tour)  # Calculate the overall difference\n    new_distance_matrix = distance_matrix * (1 + edge_n_used)  # Update distance matrix based on edges used and number of times each edge is used\n    impact = np.sum(new_distance_matrix, axis=1)  # Calculate the impact of each node based on the updated distance matrix\n    perturb_nodes = np.argsort(impact)[::-1]  # Sort nodes based on impact in descending order\n    return new_distance_matrix, perturb_nodes",
          "objective": 1.486,
          "first_obj": null
     }
}