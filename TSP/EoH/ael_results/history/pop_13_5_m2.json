{
     "parent1": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the product of the local and global optimum tours and the edge usage, and then sorts the nodes based on the maximum product of edge usage and the summation of local and global optimum tours to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    product_metric = (local_opt_tour * global_opt_tour) * edge_n_used\n    new_distance_matrix = distance_matrix + product_metric\n    \n    perturb_nodes = np.argsort(np.maximum(np.max(product_metric, axis=1), np.sum([local_opt_tour, global_opt_tour], axis=0)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.31444,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nCreate a new algorithm that updates the distance matrix by taking the sum of the local and global optimum tours and the edge usage, and then sorts the nodes based on the maximum sum of edge usage and the maximum of local and global optimum tours to identify the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    sum_metric = (local_opt_tour + global_opt_tour) + edge_n_used\n    new_distance_matrix = distance_matrix + sum_metric\n    \n    perturb_nodes = np.argsort(np.maximum(np.max(sum_metric, axis=1), np.max([local_opt_tour, global_opt_tour], axis=0)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.28009,
          "other_inf": null
     }
}