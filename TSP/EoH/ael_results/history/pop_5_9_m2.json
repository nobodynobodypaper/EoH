{
     "parent1": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the pairwise differences of edge counts between the current local optimal tour and a randomly perturbed tour to encourage exploration of different routes and avoid getting trapped in local optimums.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_counts_diff = np.zeros_like(edge_distance)\n    for _ in range(5):  # Perturb the local_opt_tour 5 times\n        np.random.shuffle(local_opt_tour)  # Randomly perturb the tour\n        perturbed_edge_counts = np.zeros_like(edge_distance)\n        for i in range(len(local_opt_tour) - 1):\n            start = local_opt_tour[i]\n            end = local_opt_tour[i + 1]\n            perturbed_edge_counts[start][end] += 1\n            perturbed_edge_counts[end][start] += 1\n        edge_counts_diff += np.abs(perturbed_edge_counts - edge_n_used)\n    \n    normalization_factor = 1 / (np.max(edge_counts_diff) + 1)\n    updated_edge_distance += edge_counts_diff * normalization_factor\n    \n    return updated_edge_distance",
          "objective": 3.07814,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Update the edge distances in the edge distance matrix based on the pairwise averages of edge counts between the current local optimal tour and a randomly perturbed tour to encourage exploration of different routes and avoid getting trapped in local optimums.\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    edge_counts_avg = np.zeros_like(edge_distance)\n    for _ in range(5):  # Perturb the local_opt_tour 5 times\n        np.random.shuffle(local_opt_tour)  # Randomly perturb the tour\n        perturbed_edge_counts = np.zeros_like(edge_distance)\n        for i in range(len(local_opt_tour) - 1):\n            start = local_opt_tour[i]\n            end = local_opt_tour[i + 1]\n            perturbed_edge_counts[start][end] += 1\n            perturbed_edge_counts[end][start] += 1\n        edge_counts_avg += perturbed_edge_counts\n    \n    edge_counts_avg /= 5  # Average edge counts\n    normalization_factor = 1 / (np.max(edge_counts_avg) + 1)\n    updated_edge_distance += edge_counts_avg * normalization_factor\n    \n    return updated_edge_distance",
          "objective": 0.63157,
          "other_inf": null
     }
}