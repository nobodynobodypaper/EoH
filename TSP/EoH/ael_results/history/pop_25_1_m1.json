{
     "parent1": {
          "algorithm": "Create a new algorithm that updates the distance matrix by taking the maximum of the absolute difference between local and global optimum tours, normalized edge usage, and random perturbation, then sorts the nodes based on the maximum edge usage and minimum distance from the global optimum tour to determine the top nodes for perturbation.",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference = np.abs(local_opt_tour - global_opt_tour)\n    normalized_edge_usage = edge_n_used / np.max(edge_n_used)\n    random_perturbation = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    \n    new_distance_matrix = distance_matrix + np.maximum(tour_difference, np.maximum(normalized_edge_usage, random_perturbation))\n    perturb_nodes = np.argsort(np.maximum(np.max(edge_n_used, axis=1), np.min(new_distance_matrix, axis=1)))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.09414,
          "other_inf": null
     },
     "offspring": {
          "algorithm": "\nNew algorithm: Update the distance matrix by taking the maximum of the absolute difference between local and global optimum tours, normalized edge usage, and a combination of random perturbation and neighborhood optimization, then sort the nodes based on the maximum edge usage and minimum distance from the global optimum tour to determine the top nodes for perturbation.\n",
          "code": "import numpy as np\n\ndef get_matrix_and_nodes(distance_matrix, local_opt_tour, global_opt_tour, edge_n_used):\n    tour_difference = np.abs(local_opt_tour - global_opt_tour)\n    normalized_edge_usage = edge_n_used / np.max(edge_n_used)\n    random_perturbation = np.random.rand(distance_matrix.shape[0], distance_matrix.shape[1])\n    \n    neighbor_optimization = np.minimum(distance_matrix, np.roll(distance_matrix, 1, axis=0))\n    \n    new_distance_matrix = distance_matrix + np.maximum(tour_difference, np.maximum(normalized_edge_usage, random_perturbation + neighbor_optimization))\n    perturb_nodes = np.argsort(-np.max(edge_n_used, axis=1) + np.min(new_distance_matrix, axis=1))\n    \n    return new_distance_matrix, perturb_nodes",
          "objective": 0.39381,
          "other_inf": null
     }
}